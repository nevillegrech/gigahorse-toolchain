
.decl StatementDominates(stmt1: Statement, stmt2: Statement) inline

StatementDominates(stmt1, stmt2):-
  Statement_Block(stmt1, block1),
  Statement_Block(stmt2, block2),
  (Dominates(block1, block2) ; LocalStatementPathInBlock(stmt1, stmt2)).


/**
  Base case for struct allocations

  @param  mload       MLOAD statement loading the free memory pointer address
  @param  mstore      MSTORE statement updating the free memory pointer
  @param  structBase  Variable pointing to the 0th word of the struct. Identifies the struct instance.
  @param  wordWidth   Width of the struct in words
*/
.decl PossibleStructAllocation(mload: Statement, mstore: Statement, structBase: Variable, wordWidth: number)
DEBUG_OUTPUT(PossibleStructAllocation)

// TODO: Reintroduce Internal variant if needed
// .decl StructAllocationInternal(mstore: Statement, structBase: Variable, wordWidth: number)
// DEBUG_OUTPUT(StructAllocationInternal)

.decl Struct_WordWidth(structBase: Variable, wordWidth: number)
DEBUG_OUTPUT(Struct_WordWidth)

/**
  Initial stores are the ones that happen during the struct's allocation 
*/
.decl InitialStoreToPossibleStruct(mstore: Statement, structBase: Variable, storedVar: Variable, wordOffset: number)
DEBUG_OUTPUT(InitialStoreToPossibleStruct)

/**
  Helper to disqualify memory constructs that fit the patterns for both structs and constant arrays.
  This is an issue because array and struct inference are mutually recursive and we cannot
  use recursion.
*/
.decl ProbablyConstantArray(structBase: Variable)
DEBUG_OUTPUT(ProbablyConstantArray)

.decl StructIndex(structBase: Variable, indexVar: Variable, wordOffset: number)
DEBUG_OUTPUT(StructIndex)

.decl StructContainsArray(structBase: Variable, wordOffset: number, elementSize: number)
DEBUG_OUTPUT(StructContainsArray)


// REVIEW: Make sure this doesn't cause any imprecision with other patterns or array allocations with constant length
// REVIEW: This is rather conservative right now as I imagine these patterns produced by the compiler are.
// May need to make them more general with regard to aliasing.

PossibleStructAllocation(mload, freePtrUpdStore, structBase, memDiff / 32):-
  MLOADFreePtr_To(mload, structBase),
  FreePointerBasedValue(updateVal, mload, _, memDiff),
  memDiff % 32 = 0,
  memDiff / 32 > 0,
  Variable_SymbolicValue(updatedFMP, updateVal),
  MSTORE(freePtrUpdStore, _, updatedFMP),
  MSTOREFreePtr(freePtrUpdStore).

InitialStoreToPossibleStruct(mstore, structBaseVar, storedVar, memOffset / 32):-
  PossibleStructAllocation(mload, freePtrUpdStore, structBaseVar, wordWidth),
  FreePointerBasedValue(storeIndexVal, mload, _, memOffset),
  memOffset % 32 = 0,
  memOffset / 32 < wordWidth,
  Variable_SymbolicValue(memIndex, storeIndexVal),
  MSTORE(mstore, memIndex, storedVar),
  StatementDominates(mload, mstore),
  StatementDominates(mstore, freePtrUpdStore).

ProbablyConstantArray(probablyArrayVar):-
  PossibleStructAllocation(_, _, probablyArrayVar, _),
  stores =  count : InitialStoreToPossibleStruct(_, probablyArrayVar, _, _),
  stores > 0,
  stores =  count : {
    InitialStoreToPossibleStruct(_, probablyArrayVar, storedVar, _),
    BasicVariable_Value(storedVar, _)
  }.

/**
  Memory bounds check for struct allocations
  Present in code produced by the viaIR pipeline
*/
.decl StructAllocationCheck(structBase: Variable)
DEBUG_OUTPUT(StructAllocationCheck)

StructAllocationCheck(structBase):-
  PossibleStructAllocation(_, freePtrUpdStore, structBase, _),
  MSTORE(freePtrUpdStore, _, storedVar),
  LT(_, storedVar, structBase, pt1),
  GT(_, storedVar, memLimitVar, pt2),
  Variable_Value(memLimitVar, "0xffffffffffffffff"),
  (OR(_, pt1, pt2, condVar); OR(_, pt2, pt1, condVar)),
  JUMPI(jmpi, _, condVar),
  ControlsWith(jmpi, throwBlock, condVar),
  ThrowBlock(throwBlock).

// REVIEW: it requires at least as many InitialStoreToPossibleStruct as the struct's words
// it may possibly not be the case in optimized code
// REVIEW: only infers the structs in cases where it escapes the current method
// MSTORE/MLOAD modeling is considered suficient in other cases
StructAllocation(freePtrUpdStore, structBaseVar, wordWidth):-
  PossibleStructAllocation(_, freePtrUpdStore, structBaseVar, wordWidth),
  wordWidth >= count : InitialStoreToPossibleStruct(_, structBaseVar, _, _),
  LocalFlows(structBaseVar, argOrRet),
  (ActualArgs(_, argOrRet, _) ; FormalReturnArgs(_, argOrRet, _)),
  !ProbablyConstantArray(structBaseVar).

StructAllocation(freePtrUpdStore, structBaseVar, wordWidth):-
  PossibleStructAllocation(_, freePtrUpdStore, structBaseVar, wordWidth),
  StructAllocationCheck(structBaseVar),
  LocalFlows(structBaseVar, argOrRet),
  (ActualArgs(_, argOrRet, _) ; FormalReturnArgs(_, argOrRet, _)),
  !ProbablyConstantArray(structBaseVar).

Struct_WordWidth(structBase, wordWidth):-
  StructAllocation(_, structBase, wordWidth).

StructIndex(structBaseVar, indexVar, memOffset / 32):-
  Struct_WordWidth(structBaseVar, wordWidth),
  Statement_Defines(mload, structBaseVar, _),
  Variable_SymbolicValue(structBaseVar, structBaseVal),
  FreePointerBasedValuesNumDiffNoMemReuse(indexValue, structBaseVal, memOffset),
  memOffset % 32 = 0,
  memOffset / 32 < wordWidth,
  Variable_SymbolicValue(indexVar, indexValue),
  Statement_Defines(indexDefStmt, indexVar, _),
  StatementDominates(mload, indexDefStmt).

// Special case for formal args
StructIndex(structBaseVar, indexVar, memOffset / 32):-
  Struct_WordWidth(structBaseVar, wordWidth),
  !Statement_Defines(_, structBaseVar, _),
  Variable_SymbolicValue(structBaseVar, structBaseVal),
  FreePointerBasedValuesNumDiffNoMemReuse(indexValue, structBaseVal, memOffset),
  memOffset % 32 = 0,
  memOffset / 32 < wordWidth,
  Variable_SymbolicValue(indexVar, indexValue).

StructLoad(mload, structBase, wordOffset, loadedVar):-
  StructIndex(structBase, indexVar, wordOffset),
  MLOAD(mload, indexVar, loadedVar).

StructStore(mstore, structBase, wordOffset, storedVar):-
  StructIndex(structBase, indexVar, wordOffset),
  MSTORE(mstore, indexVar, storedVar).

StructContainsArray(structBase, wordOffset, @hex_to_number(elementSize)):-
  StructStore(_, structBase, wordOffset, storedVar),
  IsRegularArrayVar(storedVar),
  Array_ElementLength(storedVar, elementSize).

MemoryModelingTempStmt(mstore):-
  StructAllocation(mstore, _, _).

/**
  Hack to model structs passed through function args/rets
*/
.decl PossibleStruct(structVar: Variable)
DEBUG_OUTPUT(PossibleStruct)

/**
  PossibleStructArg is used to add new symbolic values for memory addresses to the formal argument variables
*/
.decl PossibleStructArg(function: Function, actual: Variable, formal: Variable)
DEBUG_OUTPUT(PossibleStructArg)

/**
  PossibleStructRet is used to add new symbolic values for memory addresses to the actual return variables
*/
.decl PossibleStructRet(function: Function, actual: Variable, formal: Variable)
DEBUG_OUTPUT(PossibleStructRet)

PossibleStruct(possibleStruct):-
  PossibleStructAllocation(_, _, possibleStruct, _);
  PossibleStructRet(_, possibleStruct, _);
  PossibleStructArg(_, _, possibleStruct).

PossibleStructArg(function, actual, formal):-
  ActualArgs(caller, actual, pos),
  PossibleStruct(actual),
  CallGraphEdge(caller, function),
  FormalArgs(function, formal, pos).

PossibleStructRet(function, actual, formal):-
  FormalReturnArgs(function, formal, pos),
  PossibleStruct(formal),
  CallGraphEdge(caller, function),
  ActualReturnArgs(caller, actual, pos).


.decl StructArg(caller: Block, function: Function, pos: number, actual: Variable, formal: Variable)
DEBUG_OUTPUT(StructArg)

.decl StructRet(caller: Block, function: Function, pos: number, actual: Variable, formal: Variable)
DEBUG_OUTPUT(StructRet)

StructArg(caller, function, pos, actual, formal):-
  ActualArgs(caller, actual, pos),
  Struct_WordWidth(actual, _),
  CallGraphEdge(caller, function),
  FormalArgs(function, formal, pos).

StructRet(caller, function, pos, actual, formal):-
  FormalReturnArgs(function, formal, pos),
  Struct_WordWidth(formal, _),
  CallGraphEdge(caller, function),
  ActualReturnArgs(caller, actual, pos).

Struct_WordWidth(formal, wordWidth):-
  StructArg(_, _, _, actual, formal),
  Struct_WordWidth(actual, wordWidth).

Struct_WordWidth(actual, wordWidth):-
  StructRet(_, _, _, actual, formal),
  Struct_WordWidth(formal, wordWidth).

StructContainsArray(formal, wordOffset, elementSize):-
  StructArg(_, _, _, actual, formal),
  StructContainsArray(actual, wordOffset, elementSize).

IsRegularArrayVar(loadedVar),
Array_ElementLength(loadedVar, @number_to_hex(elementSize)):-
  StructContainsArray(formal, wordOffset, elementSize),
  StructArg(_, _, _, _, formal),
  StructLoad(_, formal, wordOffset, loadedVar).