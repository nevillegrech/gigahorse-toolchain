#pragma once

//// ** Recognize structured loops and related stuff **

.decl StructuredLoopBackEdge(from: Block, to: Block)
.decl StructuredLoopHead(s: Block)

StructuredLoopBackEdge(from, to),
StructuredLoopHead(to) :-
  LocalBlockEdge(from, to),
  Dominates(to, from).

// Detect a loop body *without* also capturing surrounding loops (i.e., not just SCC)
.decl BlockInStructuredLoop(s: Block, loophead: Block)
/**
  Base of above relation, blocks that can reach the loop head
*/
.decl BlockInStructuredLoopBase(s: Block, loophead: Block)

BlockInStructuredLoopBase(backEdgeNode, loophead) :- StructuredLoopBackEdge(backEdgeNode, loophead).
BlockInStructuredLoopBase(loophead, loophead) :- StructuredLoopHead(loophead).

// Can reach back edge node without going through loop head!
BlockInStructuredLoopBase(s, loophead) :-
  BlockInStructuredLoopBase(other, loophead),
  LocalBlockEdge(s, other),
  other != loophead.

BlockInStructuredLoop(block, loop):-
  BlockInStructuredLoopBase(block, loop).

// If non terminating loop exit exists, consider terminating ones part of the loop
BlockInStructuredLoop(termBlock, loop):-
  LoopToExitingBlock(loop, termBlock).

// recursive case of the above
BlockInStructuredLoop(termBlock, loop):-
  LoopToExitingBlock(loop, termOne),
  // reverts can span across multiple blocks (connected via direct jumps)
  LocalBlockPath(termOne, termBlock).

// If non-terminating or exiting loop exit exists, consider reverting ones part of the loop
BlockInStructuredLoop(termBlock, loop):-
  LoopToRevertingBlock(loop, termBlock).

// recursive case of the above
BlockInStructuredLoop(termBlock, loop):-
  LoopToRevertingBlock(loop, termOne),
  // reverts can span across multiple blocks (connected via direct jumps)
  LocalBlockPath(termOne, termBlock).


BlockInStructuredLoop(addBlock, loop):-
  LoopWithManyExitsHasSingleConvergenceBlock(loop, _),
  LoopWithManyExitsHasAdditionalBlocks(loop, addBlock).

.decl StatementInStructuredLoop(s: Statement, loop: Block)
StatementInStructuredLoop(s, loop) :-
   BlockInStructuredLoop(b, loop),
   Statement_Block(s, b).


/**
  Block that will be executed after the loop completes.
  We first define `LoopNextBase` as an exit to a non immediately terminating block.  
  If such a fact exists, we consider it `LoopNext` and "exits" to terminating blocks as part of the loop.  
  If no such fact is produced we consider exits to terminating blocks as `LoopNext` facts.
  (This mostly covers cases where a revert message is copied using a loop, followed by a `REVERT`).
*/
.decl LoopNext(loop: Block, next: Block)
DEBUG_OUTPUT(LoopNext)
// Internal relation: Loop exits to a non immediately-terminating block
.decl LoopNextBase(loop: Block, next: Block)
DEBUG_OUTPUT(LoopNextBase)
// Internal relation: Loop exits to a terminating (with regards to the current function) block 
// (revert, exit, returnprivate, return)
.decl LoopToExitingBlock(loop: Block, termBlock: Block)
// Internal relation: Loop "exits" to a reverting block 
.decl LoopToRevertingBlock(loop: Block, termBlock: Block)

// A terminating or reverting exist can be reached from outside the loop. 
.decl LoopToSecondaryExitReachableFromOutside(loop: Block, exit: Block)

LoopNext(loop, next):-
  LoopNextBase(loop, next),
  !LoopWithManyExitsHasSingleConvergenceBlock(loop, _).

LoopNext(loop, conBlock):-
  LoopNextBase(loop, _),
  LoopWithManyExitsHasSingleConvergenceBlock(loop, conBlock).

LoopNextBase(loop, termBlock):-
  (LoopToExitingBlock(loop, termBlock); LoopToRevertingBlock(loop, termBlock)),
  LoopToSecondaryExitReachableFromOutside(loop, termBlock).


LoopNextBase(loop, out):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, out),
  !BlockInStructuredLoopBase(out, loop),
  !ThrowBlock(out),
  !BlockMustThrow(out),
  !BlockTerminates(out).

LoopToRevertingBlock(loop, termBlock):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, termBlock),
  !LoopToSecondaryExitReachableFromOutside(loop, termBlock),
  (ThrowBlock(termBlock); BlockMustThrow(termBlock)).
.output LoopToExitingBlock, LoopToRevertingBlock, LoopToSecondaryExitReachableFromOutside, BlockMustThrow, BlockMustReturn, BlockMayReturn, BlockMayThrow
LoopToExitingBlock(loop, termBlock):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, termBlock),
  !LoopToSecondaryExitReachableFromOutside(loop, termBlock),
  BlockTerminates(termBlock).

LoopToSecondaryExitReachableFromOutside(loop, block):-
  BlockInStructuredLoopBase(inLoop, loop),
  LocalBlockEdge(inLoop, block),
  LocalBlockEdge(other, block),
  block != loop, // is not the loophead
  !BlockInStructuredLoopBase(other, loop).

LoopNextBase(loop, termBlock):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, termBlock),
  LoopToSecondaryExitReachableFromOutside(loop, termBlock),
  (ThrowBlock(termBlock); BlockMustThrow(termBlock)).

LoopNextBase(loop, termBlock):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, termBlock),
  LoopToSecondaryExitReachableFromOutside(loop, termBlock),
  BlockTerminates(termBlock).

/**
  The following relations are about 
*/

/**
  Forward-only reachability.
*/
.decl LocalBlockPathExclBackEdges(from: Block, to: Block)
LocalBlockPathExclBackEdges(block, block):-
  LocalBlockEdge(block, _);
  LocalBlockEdge(_, block);
  Statement_Block(_, block).

LocalBlockPathExclBackEdges(from, to):-
  LocalBlockPathExclBackEdges(from, mid),
  LocalBlockEdge(mid, to),
  !StructuredLoopBackEdge(mid, to).

.decl LoopHasMultipleExitPoints(loop: Block, n_exit: number)
LoopHasMultipleExitPoints(loop, n):-
  LoopNextBase(loop, _),
  n = count: LoopNextBase(loop, _),
  n > 1.

.decl LoopNextReachesBlock(loop: Block, next: Block, reaches: Block)
DEBUG_OUTPUT(LoopNextReachesBlock)
LoopNextReachesBlock(loop, next, next):-
  LoopNextBase(loop, next).

LoopNextReachesBlock(loop, next, to):-
  LoopNextBase(loop, next),
  LocalBlockPathExclBackEdges(next, to).

.decl Loop_BlockReachableFromNNexts(loop: Block, block: Block, n: number)
DEBUG_OUTPUT(Loop_BlockReachableFromNNexts)
Loop_BlockReachableFromNNexts(loop, block, n):-
  LoopNextReachesBlock(loop, _, block),
  n = count: LoopNextReachesBlock(loop, _, block).

.decl LoopNextsConverge(loop: Block, conBlock: Block)
DEBUG_OUTPUT(LoopNextsConverge)
LoopNextsConverge(loop, conBlock):-
  LoopHasMultipleExitPoints(loop, n),
  Loop_BlockReachableFromNNexts(loop, conBlock, n),
  LocalBlockEdge(otherBlock, conBlock),
  Loop_BlockReachableFromNNexts(loop, otherBlock, m),
  m < n.

/**
  We try to resolve a single convergence block for loops with multiple
  non immediately reverting/exiting exits. This is considered the `LoopNext`.
*/
.decl LoopWithManyExitsHasSingleConvergenceBlock(loop: Block, conBlock: Block)
LoopWithManyExitsHasSingleConvergenceBlock(loop, conBlock):-
  LoopHasMultipleExitPoints(loop, _),
  LoopNextsConverge(loop, conBlock),
  1 = count: LoopNextsConverge(loop, _).

/**
  When `LoopWithManyExitsHasSingleConvergenceBlock` holds, we find blocks from
  `LoopNextBase` to the convergence block, to consider them part of the loop.
*/
.decl LoopWithManyExitsHasAdditionalBlocks(loop: Block, addBlock: Block)

LoopWithManyExitsHasAdditionalBlocks(loop, addBlock):-
  LoopWithManyExitsHasSingleConvergenceBlock(loop, conBlock),
  LoopNextBase(loop, addBlock),
  addBlock != conBlock.

LoopWithManyExitsHasAdditionalBlocks(loop, addBlock):-
  LoopWithManyExitsHasAdditionalBlocks(loop, block),
  LoopWithManyExitsHasSingleConvergenceBlock(loop, conBlock),
  LocalBlockEdge(block, addBlock),
  addBlock != conBlock.

/**
  Basic relation for identifying post-iteration blocks.
  A likely continue jump is one that where the `to` block dominates the loop's BackEdge block,
  while the `from` doesn't.
*/
.decl LikelyContinueJump(loop: Block, block: Block, next: Block) btree_delete
DEBUG_OUTPUT(LikelyContinueJump)
LikelyContinueJump(loop, block, next):-
  StructuredLoopBackEdge(finalBlock, loop),
  BlockInStructuredLoopBase(block, loop),
  BlockInStructuredLoopBase(next, loop),
  LocalBlockEdge(block, next),
  Dominates(next, finalBlock),
  !Dominates(block, finalBlock).

// Filter out inferences for the same loop if one PostDominates the other
LikelyContinueJump(loop, otherBlock, otherNext) <= LikelyContinueJump(loop, block, next):-
  PostDominates(next, otherNext),
  next != otherNext.

/**
  Infer that a loop has post-iteration logic if:
    * It has a single LoopBackEdge
    * All LikelyContinueJumps have the same target
*/
.decl LoopHasPostIterationLogic(loop: Block, startPoint: Block)
DEBUG_OUTPUT(LoopHasPostIterationLogic)
LoopHasPostIterationLogic(loop, next):-
  BlockInStructuredLoopBase(_, loop),
  1 = count: StructuredLoopBackEdge(_, loop),
  LikelyContinueJump(loop, _, next),
  n = count: LikelyContinueJump(loop, _, _),
  n = count: LikelyContinueJump(loop, _, next),
  n > 1.

.decl BlockInPostIterationBlock(loop: Block, postB: Block)
BlockInPostIterationBlock(loop, next):-
  LoopHasPostIterationLogic(loop, next).

BlockInPostIterationBlock(loop, next):-
  BlockInPostIterationBlock(loop, block),
  LocalBlockEdge(block, next),
  BlockInStructuredLoopBase(next, loop),
  !StructuredLoopBackEdge(block, loop).

.decl StatementInPostIterationBlock(loop: Block, stmt: Statement)
StatementInPostIterationBlock(loop, stmt):-
  BlockInPostIterationBlock(loop, block),
  Statement_Block(stmt, block).

/**
  Loops that can be expressed using high-level control-flow.
  They have to have exactly 1 exit/next block or have many
  but of the kinds that can be also part of the loop (returns, reverts, exits, etc)
*/
.decl HighLevelLoop(loop: Block)
HighLevelLoop(loop):-
  BlockInStructuredLoop(_, loop),
  1 = count : LoopNext(loop, _).

HighLevelLoop(loop):-
  BlockInStructuredLoop(_, loop),
  (LoopToExitingBlock(loop, _); LoopToRevertingBlock(loop, _)),
  !LoopNext(loop, _).



// condVar determines whether a loop is exited
.decl LoopExitCond(condVar: Variable, loop: Block)
.decl LoopExitCondPredicateTrue(condVar: Variable, loop: Block, if_head: Block)
.decl LoopExitCondPredicateFalse(condVar: Variable, loop: Block, if_head: Block)

LoopExitCond(condVar, loop) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   LocalBlockEdge(jmpiBlock, out),
   // in many cases LoopNextBase will be different than LoopNext
   // we need it for completeness
   (LoopNext(loop, out); LoopNextBase(loop, out); LoopToExitingBlock(loop, out); LoopToRevertingBlock(loop, out)),
   LocalBlockEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).


LoopExitCondPredicateTrue(condVar, loop, jmpiBlock) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   LocalBlockEdge(jmpiBlock, out),
   // in many cases LoopNextBase will be different than LoopNext
   // we need it for completeness
   (LoopNext(loop, out); LoopNextBase(loop, out); LoopToExitingBlock(loop, out); LoopToRevertingBlock(loop, out)),
   FallthroughEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).

DEBUG_OUTPUT(LoopExitCond)
DEBUG_OUTPUT(LoopExitCondPredicateTrue)
DEBUG_OUTPUT(LoopExitCondPredicateFalse)
LoopExitCondPredicateFalse(condVar, loop, jmpiBlock) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   FallthroughEdge(jmpiBlock, out),
   // in many cases LoopNextBase will be different than LoopNext
   // we need it for completeness
   (LoopNext(loop, out); LoopNextBase(loop, out); LoopToExitingBlock(loop, out); LoopToRevertingBlock(loop, out)),
   LocalBlockEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).


.decl CanReachBlock(s:Block, t:Block)

CanReachBlock(x, y), CanReachBlock(y, y), CanReachBlock(x, x) :- LocalBlockEdge(x, y).
CanReachBlock(x, z) :- CanReachBlock(x, y), LocalBlockEdge(y, z).

.decl InSameSCC(x:Block, y:Block)
InSameSCC(y, y), InSameSCC(x, x) :- LocalBlockEdge(x, y).
InSameSCC(x, y) :- CanReachBlock(x,y), CanReachBlock(y,x).

.decl InSameSCCLoop(x:Block, y:Block)
InSameSCCLoop(x, y) :- InSameSCC(x, y), (x != y ; LocalBlockEdge(x, y)).

.decl BlockInSCCLoop(x:Block, scc: number)

BlockInSCCLoop(x, scc) :-
   IsBlock(x),
   scc = min ord(y) : InSameSCCLoop(x, y).



