#pragma once

/**
  Intra-procedural, block-level.  
  There is a path from the entry to `block` that does not go through `candidate`.
*/
.decl DoesNotDominate(candidate: Block, block: Block)
DoesNotDominate(candidate,s) :-
  FunctionEntry(s),
  InFunction(s, f), 
  InFunction(candidate, f),
  candidate != s.

DoesNotDominate(notdom, s) :-
  DoesNotDominate(notdom, other),
  LocalBlockEdge(other, s), s != notdom.

/**
  Intra-procedural, block-level.  
  There is a path from `block` to the exit that does not go through `candidate`
*/
.decl DoesNotPostDominate(candidate: Block, block: Block)
DoesNotPostDominate(candidate, exitNode) :-
  FunctionExit(exitNode),
  InFunction(exitNode, f),
  InFunction(candidate, f),
  exitNode != candidate.

DoesNotPostDominate(candidate, s) :-
  DoesNotPostDominate(candidate, other),
  LocalBlockEdge(s, other),
  s != candidate.

/**
  The Dominates/PostDominates relation is defined on basic blocks,
  represented by their first instruction (Bhead). Defining
  a dense quadratic relation, like Dominates, on individual
  instructions would be expensive.
*/

/**
  Intra-procedural, block-level.  
  Every path from the entry to `block` goes through `dominator`.
*/
.decl Dominates(dominator: Block, block: Block)
Dominates(dominator,s) :-
  InFunction(dominator, f),
  InFunction(s, f),
  !DoesNotDominate(dominator,s).

/**
  Intra-procedural, block-level.  
  Every path from `block` to the exit goes through `postdominator`.
*/
.decl PostDominates(postdominator: Block, s: Block)
PostDominates(postdominator,s) :-
  InFunction(postdominator, f),
  InFunction(s, f),
  !DoesNotPostDominate(postdominator,s).

/**
  Intra-block, statement-level.  
  For every execution `statement` is followed by `postdominator`.
*/
.decl PostDominatesInBlock(postdominator: Statement, statement: Statement)
        
PostDominatesInBlock(stmt2, stmt) :-
  Statement_Next(stmt, stmt2),
  Statement_Block(stmt, block),
  Statement_Block(stmt2, block).

PostDominatesInBlock(stmt3, stmt1) :-
  PostDominatesInBlock(stmt2, stmt1),
  Statement_Next(stmt2, stmt3),
  Statement_Block(stmt2, block),
  Statement_Block(stmt3, block).


/**
  Intra-procedural, block-level.  
  May-HappensAfter relation.  
  __Note:__ To be used with caution because it can be very slow.  
*/
.decl HappensAfter(next: Statement, stmt: Statement)
.decl HappensAfterBase(next: Statement, stmt: Statement)

HappensAfterBase(next, stmt) :-
  Statement_Next(stmt, next),
  Statement_Block(stmt, block),
  Statement_Block(next, block).

HappensAfterBase(nextstmt, stmt) :-
  LocalBlockEdge(from, to),
  Statement_Block(stmt, from),
  Statement_Block(nextstmt, to).

HappensAfter(next, stmt) :-
  HappensAfterBase(next, stmt).
  
HappensAfter(nextnext, stmt) :-
  HappensAfter(next, stmt),
  HappensAfterBase(nextnext, next).


/**
  Helper control-flow-related predicates
*/


/**
  Intra-procedural, block-level.  
  There is a path where `from` is executed before `to`.
*/
.decl LocalBlockPath(from: Block, to: Block)

LocalBlockPath(src, target):-
  LocalBlockEdge(src, target).

LocalBlockPath(src, target):-
  LocalBlockPath(src, mid),
  LocalBlockEdge(mid, target).

// The opposite of `PostDominatesInBlock`, really
.decl LocalStatementPathInBlock(from: Statement, to: Statement)

LocalStatementPathInBlock(stmt1, stmt2):-
  Helper_NextStatementInSameBlock(stmt1, stmt2).

LocalStatementPathInBlock(stmt1, stmt3):-
  LocalStatementPathInBlock(stmt1, stmt2),
  Helper_NextStatementInSameBlock(stmt2, stmt3).

/**
  Component used to get a cheap statement-level global may happen before relation if we can describe the sets of statements
  relevant to our query at compile time.
  This can be used to answer questions like: "Can we have two SSTORE statements to the same address, one followed by the other?"

  This is useful because computing such relations (all-pairs) at the statement-level is prohibitively expensive
  but computing them top-down (on demand) like this makes it very cheap even inter-procedurally.

  The `Before(before: Statement, arg: symbol)` and `After(after: Statement, arg: symbol)` input relations
  are populated at every instantiation of the component to describe the relevant sets of statements for our query.

  Output relation `MayHappenBefore(before: Statement, after: Statement, arg: symbol)` will contain a subset of statements `before`,`after` such that
  statement `before` can be executed before statement `after` for some program path. Both statements are associated with the same `arg`.

  Only external (outside of the component) library relations used are `LocalStatementPathInBlock` and `LocalBlockPath`.

  The example described above would be:

    .init storesSameAddress = MayHappenBeforeGlobalWithArg
    storesSameAddress.Before(before, val):- SSTORE(before, var, _), Variable_Value(var, val).
    storesSameAddress.After(after, val):- SSTORE(after, var, _), Variable_Value(var, val).
*/
.comp MayHappenBeforeGlobalWithArg {
  // Input relations
  .decl Before(before: Statement, arg: symbol)
  .decl After(after: Statement, arg: symbol)

  // Output relation 'before' can happen before 'after'
  .decl MayHappenBefore(before: Statement, after: Statement, arg: symbol)

  // Output relation 'before' will happen before 'after'
  .decl WillHappenBefore(before: Statement, after: Statement, arg: symbol)

  // Intermediate relations. These start before the original `before` and `after` statements populating the input relations
  // and transitively go back through function calls to work inter-procedurally
  // originalBefore/After are kept because to report the original statements, before/after is what changes when going through private calls
  // before/afterBlock, before/afterFunction are relative to before/after and not the original ones and are in the relation to enable more efficient joins.
  .decl BeforeInfo(originalBefore: Statement, before: Statement, beforeBlock: Block, beforeFunction: Function, arg: symbol)
  .decl AfterInfo(originalAfter: Statement, after: Statement, afterBlock: Block, afterFunction: Function, arg: symbol)

  // base case, starting from Before
  BeforeInfo(before, before, beforeBlock, beforeFunction, arg):-
    Before(before, arg),
    Statement_Block(before, beforeBlock),
    InFunction(beforeBlock, beforeFunction).

  // base case, starting before After
  AfterInfo(after, after, afterBlock, afterFunction, arg):-
    After(after, arg),
    Statement_Block(after, afterBlock),
    InFunction(afterBlock, afterFunction).

  // transitive case: moving backwards through function calls
  BeforeInfo(originalBefore, callStmt, calleeBlock, calleeFunction, arg):-
    BeforeInfo(originalBefore, _, _, beforeFunction, arg),
    CallGraphEdge(calleeBlock, beforeFunction),
    InFunction(calleeBlock, calleeFunction),
    Statement_Block(callStmt, calleeBlock),
    Statement_Opcode(callStmt, "CALLPRIVATE").

  // transitive case: moving backwards through function calls
  AfterInfo(originalAfter, callStmt, calleeBlock, calleeFunction, arg):-
    AfterInfo(originalAfter, _, _, afterFunction, arg),
    CallGraphEdge(calleeBlock, afterFunction),
    InFunction(calleeBlock, calleeFunction),
    Statement_Block(callStmt, calleeBlock),
    Statement_Opcode(callStmt, "CALLPRIVATE").

  WillHappenBefore(originalBefore, originalAfter, arg),
  MayHappenBefore(originalBefore, originalAfter, arg):-
    BeforeInfo(originalBefore, before, block, fun, arg),
    AfterInfo(originalAfter, after, block, fun, arg),
    LocalStatementPathInBlock(before, after).

  MayHappenBefore(originalBefore, originalAfter, arg):-
    BeforeInfo(originalBefore, _, beforeBlock, fun, arg),
    AfterInfo(originalAfter, _, afterBlock, fun, arg), // REVIEW: maybe inverted order is faster.
    LocalBlockPath(beforeBlock, afterBlock).

  WillHappenBefore(originalBefore, originalAfter, arg):-
    BeforeInfo(originalBefore, _, beforeBlock, fun, arg),
    AfterInfo(originalAfter, _, afterBlock, fun, arg), // REVIEW: maybe inverted order is faster.
    Dominates(beforeBlock, afterBlock), beforeBlock != afterBlock.
}

/**
  Component used to get a cheap statement-level global may happen before relation if we can describe the sets of statements
  relevant to our query at compile time.
  This can be used to answer questions like: "Can we have an SSTORE statement after external call?"

  This is useful because computing such relations (all-pairs) at the statement-level is prohibitively expensive
  but computing them top-down (on demand) like this makes it very cheap even inter-procedurally.

  Internally it uses `MayHappenBeforeGlobalWithArg`.

  The `Before(before: Statement)` and `After(after: Statement)` input relations are populated
  at every instantiation of the component to describe the relevant sets of statements for our query.

  Output relation `MayHappenBefore(before: Statement, after: Statement)` will contain a subset of statements `before`,`after` such that
  statement `before` can be executed before statement `after` for some program path.

  The example described above would be:

    .init storeAfterCall = MayHappenBeforeGlobal
    storeAfterCall.Before(before):- CallStmt(before).
    storeAfterCall.After(after):- SSTORE(after, _, _).
*/

.comp MayHappenBeforeGlobal {
  // Input relations
  .decl Before(before: Statement)
  .decl After(after: Statement)

  // Output relation 'before' can happen before 'after'
  .decl MayHappenBefore(before: Statement, after: Statement)

  // Output relation 'before' will happen before 'after'
  .decl WillHappenBefore(before: Statement, after: Statement)

  .init mayHappenBeforeInternal = MayHappenBeforeGlobalWithArg

  mayHappenBeforeInternal.Before(before, "NULL"):- Before(before).
  mayHappenBeforeInternal.After(after, "NULL"):- After(after).

  MayHappenBefore(before, after):- mayHappenBeforeInternal.MayHappenBefore(before, after, "NULL").

  WillHappenBefore(before, after):- mayHappenBeforeInternal.WillHappenBefore(before, after, "NULL").
}

/**
  Component used to get a cheap statement-level global may happen before relation if we can describe the sets of statements
  relevant to our query at compile time.

  This is useful because computing such relations (all-pairs) at the statement-level is prohibitively expensive
  but computing them top-down (on demand) like this makes it very cheap even inter-procedurally.

  Internally it uses two instantiations of `MayHappenBeforeGlobal`.

  The `Before(before: Statement)`, `Between(between: Statement)`, and `After(after: Statement)` input relations
  are populated at every instantiation of the component to describe the relevant sets of statements for our query.

  Output relation `MayHappenInBetween(before: Statement, between: Statement, after: Statement)` will contain a subset of statements `before`, `between`, `after`
  such that statement `between` can be executed after statement `before` and before statement `after`, for some program path.
*/

.comp MayHappenInBetweenGlobal {
  // Input relations
  .decl Before(before: Statement)
  .decl Between(between: Statement)
  .decl After(after: Statement)

  // Output relation
  .decl MayHappenInBetween(before: Statement, between: Statement, after: Statement)

  .init beforeToBetween = MayHappenBeforeGlobal
  beforeToBetween.Before(before):- Before(before).
  beforeToBetween.After(after):- Between(after).

  .init betweenToAfter = MayHappenBeforeGlobal
  betweenToAfter.Before(before):- Between(before).
  betweenToAfter.After(after):- After(after).

  MayHappenInBetween(before, between, after):-
    beforeToBetween.MayHappenBefore(before, between),
    betweenToAfter.MayHappenBefore(between, after).
}

// .type CallStack = [callerBlock: Block, rest: CallStack]

.type CallStack = StringList


/**
  Computes (all, most of the time) the different ways a private function can be reached for the different
  public entry points.
*/
.decl FunctionReachableFromPublic(function: Function, selector: symbol, callStack: CallStack)
DEBUG_OUTPUT(FunctionReachableFromPublic)
// Can we ever have recursion? Deal with it the lazy way
.limitsize FunctionReachableFromPublic(n=50000)

/**
  Computes a single way a private function can be reached for each different public entry point.
  Outputs the list of the call statements in their TAC and original bytecode representations,
  as well as the list of the called functions
*/
.decl FunctionReachableFromPublic_Metadata(function: Function, selector: symbol, callStack: CallStack, originalCallStack: OriginalStatementList, functionList: FunctionList) choice-domain (function, selector)
DEBUG_OUTPUT(FunctionReachableFromPublic_Metadata)


FunctionReachableFromPublic(function, selectorNorm, nil):-
  PublicFunctionId(function, selectorNorm, _).

FunctionReachableFromPublic(callee, selector, @list_append(callerStack, callerBlock)):-
  FunctionReachableFromPublic(caller, selector, callerStack),
  InFunction(callerBlock, caller),
  CallGraphEdge(callerBlock, callee).

FunctionReachableFromPublic_Metadata(function, selectorNorm, nil, nil, nil):-
  PublicFunctionId(function, selectorNorm, _).

FunctionReachableFromPublic_Metadata(callee, selector, @list_append(callerStack, callerBlock), @list_concat(originalCalls, originalList), @list_append(@list_concat(functionsCalled, inlinedFuns), callee)):-
  FunctionReachableFromPublic_Metadata(caller, selector, callerStack, originalCalls, functionsCalled),
  InFunction(callerBlock, caller),
  CallGraphEdge(callerBlock, callee),
  Block_Tail(callerBlock, callStmt),
  Statement_OriginalStatementList(callStmt, originalList),
  Statement_InlineInfo(callStmt, inlinedFuns).
