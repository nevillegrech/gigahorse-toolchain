#pragma once

// The parts of the schema of the decompiler output that need to be
// imported in order to import the full three-address code
// intermediate representation. All the information is there, but this
// code, together with tac_instructions.dl, creates a different
// intermediate representation (often reusing instruction names).

.type Variable <: symbol
.type Statement <: symbol
.type Block <: symbol
.type Function <: symbol
.type Opcode <: symbol
.type Value <: symbol
.type Chunk <: number
.type OriginalStatement <: symbol



#include "tac_instructions.dl"
#include "util.dl"
#include "constants.dl"

#define FACT_INPUT(_filename) \
STR(_filename\
.facts)

#define CSV_INPUT(_filename) \
STR(_filename\
.csv)

#define STR(x) #x

#ifndef MULTI_CONTRACT
#define INPUT_RELATION(_relname)\
.input _relname(IO="file", filename = CSV_INPUT(_relname), delimiter="\t")
#else
#define INPUT_RELATION(_relname)\
.input _relname()
#endif



/* Whole bytecode as a hex string */
.decl ByteCodeHex(bytecode:symbol)
INPUT_RELATION(ByteCodeHex)


.decl OpcodePossiblyHalts(op: Opcode)
INPUT_RELATION(OpcodePossiblyHalts)

// Final decompiler outputs, code

// 1 to 1 relation from statements to Opcodes.
// Some of the opcodes are identical to the opcodes produced by EVM.
.decl Statement_Opcode(stmt:Statement, op:Opcode)
INPUT_RELATION(Statement_Opcode)

// All the Statements.
// Most statement ids correspond to actual program locations in the original code.
.decl IsStatement(stmt:Statement)
INPUT_RELATION(IsStatement)

///// Removed, with anger! Doesn't include formals, confuses everyone.
// // All the Variables
// // Some variable ids correspond to statement ids where the variable
// // is originally defined, but some don't e.g. formal arguments.
// .decl IsVariable(var: Variable)
// INPUT_RELATION(IsVariable)

// Maps statements to their basic block. Note that:
// a) A statement can (and has to) pertain to *one* basic block.
// b) A basic block may be empty.
// c) As the type system suggests, basic blocks ids *do not*
//    correspond to statement ids.
.decl Statement_Block(stmt: Statement, block: Block)
INPUT_RELATION(Statement_Block)

// Value which a variable may have. Concrete values only.
// Will be constant-folded and new values will be added during memory modeling
.decl Variable_Value(var: Variable, value: Value)
INPUT_RELATION(Variable_Value)

// Used by some components that do not need the new values created during memory modeling
// Will be constant folded
.decl BasicVariable_Value(var: Variable, value: Value)
INPUT_RELATION(BasicVariable_Value)

// Like the 2 above but in instances of inlining jump target variables point to the 'value'
// that corresponds to our representation of that block and not in the actual hexadecimal value
// of that block in the original bytecode. Used by the source decompiler.
.decl Variable_BlockValue(var: Variable, value: Value)
INPUT_RELATION(Variable_BlockValue)

// Control flow & functions

// As the name suggests, is an intra-procedural CFG.
.decl LocalBlockEdge(block: Block, nextBlock: Block)
INPUT_RELATION(LocalBlockEdge)

// A subset of LocalBlockEdge, corresponds to fallthrough edges of conditional jumps.
.decl FallthroughEdge(block: Block, nextBlock: Block)
INPUT_RELATION(FallthroughEdge)

.decl CallGraphEdge(block: Block, function: Function)
INPUT_RELATION(CallGraphEdge)

// Represents part of the callgraph for functions that are called and which return
// control flow back to the caller.
.decl FunctionCallReturn(block: Block, function: Function, return: Block)
INPUT_RELATION(FunctionCallReturn)

// All the functions, function ids do *not* correspond to the entry point block
// of said function
.decl IsFunction(func: Function)
INPUT_RELATION(IsFunction)

.decl PublicFunctionSelector(func: Function, selector: symbol)
INPUT_RELATION(PublicFunctionSelector)

// A subset of IsFunction, represents public functions. All the rest of the functions
// are private functions.
.decl IsPublicFunction(func: Function)
IsPublicFunction(func) :- PublicFunctionSelector(func, _).

// Name given to each function. May contain public signature too.
// Useful for presentation purposes.
.decl HighLevelFunctionName(func: Function, name: symbol)
INPUT_RELATION(HighLevelFunctionName)

// Selector given to each public function.


.decl EventSignatureInContract(sigHash:symbol, sigText:symbol)
INPUT_RELATION(EventSignatureInContract)

//Matching constants to public function signature hashes to resolve external calls.
.decl ConstantPossibleSigHash(constValSigHash:Value, sigText:symbol)
INPUT_RELATION(ConstantPossibleSigHash)

// Gas used per block
.decl Block_Gas(block:Block, gas:number)
INPUT_RELATION(Block_Gas)

// Relation that links blocks to statements in the original bytecode
.decl OriginalStatement_Block(stmt:OriginalStatement, block:Block)
INPUT_RELATION(OriginalStatement_Block)

// Code chunks accessed
.decl Block_CodeChunkAccessed(block: Block, chunk_id: Chunk)
INPUT_RELATION(Block_CodeChunkAccessed)

// Export max context depth of decompilation, possibly useful for client analysis tuning
.decl MaxContextDepth(n:number)
INPUT_RELATION(MaxContextDepth)

// Special instructions & data flow

// Actuals are on the function call side, the args supplied to a function call
.decl ActualArgs(caller: Block, a: Variable, pos: number)

ActualArgs(caller, a, pos - 1) :-
   Statement_Uses(s, a, pos),
   CALLPRIVATE(s, _),
   pos >= 1,
   Statement_Block(s, caller).

ActualArgs(caller, a, pos - 2) :-
   Statement_Uses(s, a, pos),
   CALLPRIVATEI(s, _, _),
   pos >= 2,
   Statement_Block(s, caller).

// Actual returns are on the function call side
.decl ActualReturnArgs(caller: Block, a: Variable, pos: number)
INPUT_RELATION(ActualReturnArgs)

// formal return args are on the function definition side
.decl FormalReturnArgs(fn: Function, a: Variable, pos: number)
FormalReturnArgs(fn, a, pos - 1) :-
   Statement_Uses(s, a, pos),
   RETURNPRIVATE(s, _),
   pos >= 1,
   Statement_Block(s, b),
   InFunction(b, fn).

FormalReturnArgs(fn, a, pos - 2) :-
   Statement_Uses(s, a, pos),
   RETURNPRIVATEI(s, _, _),
   pos >= 2,
   Statement_Block(s, b),
   InFunction(b, fn).


.decl FormalArgs(fn: Function, a: Variable, pos: number)
INPUT_RELATION(FormalArgs)


.decl Statement_Uses(stmt: Statement, var: Variable, i: number)
INPUT_RELATION(Statement_Uses)
.decl Statement_Defines(stmt: Statement, var: Variable, n: number)
INPUT_RELATION(Statement_Defines)

.decl isVariable(v: Variable)
isVariable(x) :-
   Statement_Uses(_, x, _) ; Statement_Defines(_, x, _) ; FormalArgs(_, x, _).

.decl Variable_Function(v: Variable, f: Function)
Variable_Function(v, f) :-
   (Statement_Uses(s, v, _) ;
    Statement_Defines(s, v, _)),
   Statement_Block(s, b),
   InFunction(b, f).
Variable_Function(v, f) :-
   FormalArgs(f, v, _).

// A total order which models all instructions except PHI instructions.
// PHI instrucions do not appear in this relation.
.decl Statement_Next(stmt: Statement, next: Statement)
INPUT_RELATION(Statement_Next)


// Basic block corresponding to the function's entry point
.decl FunctionEntry(block: Block)
INPUT_RELATION(FunctionEntry)

// Basic block corresponding to a function's exit points
.decl FunctionExit(block: Block)
FunctionExit(block) :-
   LocalBlockEdge(_, block),
   !LocalBlockEdge(block, _).

.decl CastBlockToFunction(block: symbol)
CastBlockToFunction(block) :- FunctionEntry(block).

// Whether a block is in a function
// Currently, blocks may in some cases be part of multiple functions
.decl InFunction(block: Block, function: Function)
INPUT_RELATION(InFunction)

.decl GlobalBlockEdge(block: Block, next: Block)

GlobalBlockEdge(block, next) :-
   LocalBlockEdge(block, next),
   !FunctionCallReturn(block, _, next).

GlobalBlockEdge(block, next) :-
   CallGraphEdge(block, function),
   InFunction(next, function),
   FunctionEntry(next).

GlobalBlockEdge(returnBlock, next) :-
   FunctionCallReturn(_, function, next),
   InFunction(returnBlock, function),
   Statement_Block(s, returnBlock),
   (RETURNPRIVATE(s, _) ; RETURNPRIVATEI(s, _, _)).

.decl LocalReachableFrom(from: Block, next: Block)
LocalReachableFrom(from, next) :-
  LocalBlockEdge(from, next).

LocalReachableFrom(from, to) :-
  LocalReachableFrom(next, to),
  LocalBlockEdge(from, next).

.decl Helper_NextStatementInSameBlock(stmt: Statement, stmtNext: Statement)

Helper_NextStatementInSameBlock(stmt1, stmt2) :-
  Statement_Next(stmt1, stmt2),
  Statement_Block(stmt1, block),
  Statement_Block(stmt2, block).


.decl Block_Head(block: Block, stmt: Statement)

// Last statement in a basic block
.decl Block_Tail(b: Block, t: Statement)

Block_Head(block, stmt) :-
  Statement_Block(stmt, block),
  !PHI(stmt, _, _),
  !Helper_NextStatementInSameBlock(_, stmt).

Block_Tail(block, stmt) :-
  Statement_Block(stmt, block),
  !PHI(stmt, _, _),
  !Helper_NextStatementInSameBlock(stmt, _).


.decl IsBlock(b: Block)

IsBlock(b) :-
  Statement_Block(_, b); LocalBlockEdge(b, _); LocalBlockEdge(_, b).

.decl Statement_Function(s: Statement, f: Function)

Statement_Function(s, f) :-
   Statement_Block(s, b),
   InFunction(b, f).

.decl Mask_Length(mask: Value, bytes: number)
INPUT_RELATION(Mask_Length)

.decl ValidGlobalTerminalBlock(block: Block)

ValidGlobalTerminalBlock(block) :-
   Block_Tail(block, tail),
   (STOP(tail) ; RETURN(tail, _, _)).

.decl GlobalEntryBlock(block: Block)

GlobalEntryBlock("0x0").

.decl FallbackFunction(func: Function)

FallbackFunction(func) :- PublicFunctionSelector(func, "0x00000000").



// Dynamic Information

// Storage Snapshot Relations
// (only contain entries when running with decompile_address in clients)

.decl StorageContents(addr: symbol, contents: symbol)
INPUT_RELATION(StorageContents)

.decl SHA3Decompositions(addr: symbol, base1: symbol, base2: symbol, offset: symbol)
INPUT_RELATION(SHA3Decompositions)
