// Code proto-vulnerabilities are loaded from a file into this relation.
// Or a new file is created depending on the definition of the preprocessor flag.
// The analysis inserts more rows
// The relation is rewritten to the file

#ifndef FIRST_CLIENT_ANALYSIS
.input ProtoVulnerability(IO="file", filename="proto_vulnerability.csv", delimiter="\t")
.input VulnerabilityProcessed(IO="file", filename="vulnerability.csv", delimiter="\t")
#endif

.decl ProtoVulnerability(
    selector: symbol,
    proto_vulnerability_type: symbol,
    statement: OriginalStatement,
    storage_location: symbol,
    json_detail: symbol
)


.decl Vulnerability(
    vulnerability_type: symbol,
    confidence: symbol,
    visibility: symbol,
    statement: Statement,
    key_selector: symbol,
    debug_template: symbol,
    debug_arg0: symbol,
    debug_arg1: symbol,
    debug_arg2: symbol,
    debug_arg3: symbol
)

.decl VulnerabilityProcessed(
    vulnerability_type: symbol,
    confidence: symbol,
    visibility: symbol,
    key_statement: OriginalStatement,
    key_selector: symbol,
    debug_template: symbol,
    debug_arg0: symbol,
    debug_arg1: symbol,
    debug_arg2: symbol,
    debug_arg3: symbol
)

#define NULL "null"


.decl VulnerabilitySimple(vulnerability_type: symbol, template: symbol, statement: Statement)
VulnerabilitySimple(a, b, c) :- VulnerabilitySimple(a, b, c).                   

Vulnerability(
  vulnerability_type, "LOW",
#ifdef DEFAULT_VISIBILITY
  DEFAULT_VISIBILITY,
#else
  "PUBLIC",
#endif
  statement, NULL, template,
  NULL, NULL, NULL, NULL) :-
   VulnerabilitySimple(vulnerability_type, template, statement).


VulnerabilityProcessed(vulnerability_type, confidence, visibility, as(key_statement, OriginalStatement), key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3):-
  Vulnerability(vulnerability_type, confidence, visibility, tacStmt, key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3),
  Statement_Function(tacStmt, function),
  FunctionReachableFromPublic(function, key_selector, _),
  Statement_OriginalStatementList(tacStmt, originalList),
  originalList = [key_statement, rest], rest = rest.

VulnerabilityProcessed(vulnerability_type, confidence, visibility, NULL, key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3):-
  Vulnerability(vulnerability_type, confidence, visibility, tacStmt, key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3),
  !Statement_OriginalStatement(tacStmt, _).

.output ProtoVulnerability(IO="file", filename="proto_vulnerability.csv", delimiter="\t")
.output VulnerabilityProcessed(IO="file", filename="vulnerability.csv", delimiter="\t")

#define PREPARE_JSON1(arg1) cat("{ ", cat(arg1, " }"))
#define PREPARE_JSON2(arg1, arg2) cat("{ ", cat(cat(arg1, ", "), cat(arg2, " }")))
#define PREPARE_JSON3(arg1, arg2, arg3) cat("{ ", cat(cat(cat(arg1, ", "), cat(arg2, ", ")), cat(arg3, " }")))
#define PREPARE_JSON4(arg1, arg2, arg3, arg4) cat("{ ", cat(  cat(cat(arg1, ", "), cat(arg2, ", ")), cat(cat(arg3, ", "), cat(arg4, " }"))))
#define QUOTE substr("\"", 0, 1)   // I could find no other way to get an escaped quote!
#define STRINGIZE(arg) cat(QUOTE, cat(arg, QUOTE))
#define JSON_ELEMENT(name, value) cat(cat(STRINGIZE(name), " : "), value)
#define JSON_LEAF(name, value) cat(cat(STRINGIZE(name), " : "), STRINGIZE(value))
#define SIGNATURE(pubSig) JSON_LEAF("callerSig", pubSig)
#define CALLEE(pubSig, pubSigHash) JSON_ELEMENT("callee", PREPARE_JSON2(JSON_LEAF("sig", pubSig), JSON_LEAF("sigHash", pubSigHash)))
#define CALL_ARG(pubSig, pubSigHash, arg) PREPARE_JSON2(CALLEE(pubSig,pubSigHash), JSON_LEAF("argPos", to_string(arg)))

