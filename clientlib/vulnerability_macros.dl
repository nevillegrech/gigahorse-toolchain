// Vulnerabilities and proto-vulnerabilities are loaded from files
// Files are empty upon fact generation
// The analysis inserts more rows and the relations are rewritten to the files

.input ProtoVulnerability(IO="file", filename="proto_vulnerability.csv", delimiter="\t")
.input VulnerabilityProcessed(IO="file", filename="vulnerability.csv", delimiter="\t")

.decl ProtoVulnerability(
    selector: symbol,
    proto_vulnerability_type: symbol,
    statement: OriginalStatement,
    storage_location: symbol,
    json_detail: symbol
)


.decl Vulnerability(
    vulnerability_type: symbol,
    confidence: symbol,
    visibility: symbol,
    statement: Statement,
    key_selector: symbol,
    debug_template: symbol,
    debug_arg0: symbol,
    debug_arg1: symbol,
    debug_arg2: symbol,
    debug_arg3: symbol
)

.decl VulnerabilityProcessed(
    vulnerability_type: symbol,
    confidence: symbol,
    visibility: symbol,
    key_statement: OriginalStatement,
    original_statement_list: OriginalStatementList,
    function_list: FunctionList,
    key_selector: symbol,
    debug_template: symbol,
    debug_arg0: symbol,
    debug_arg1: symbol,
    debug_arg2: symbol,
    debug_arg3: symbol
)

#define NULL "null"


.decl VulnerabilitySimple(vulnerability_type: symbol, template: symbol, statement: Statement)
VulnerabilitySimple(a, b, c) :- VulnerabilitySimple(a, b, c).                   

Vulnerability(
  vulnerability_type, "LOW",
#ifdef DEFAULT_VISIBILITY
  DEFAULT_VISIBILITY,
#else
  "PUBLIC",
#endif
  statement, NULL, template,
  NULL, NULL, NULL, NULL) :-
   VulnerabilitySimple(vulnerability_type, template, statement).


VulnerabilityProcessed(vulnerability_type, confidence, visibility, as(key_statement, OriginalStatement), @list_concat(listPart1, originalList), @list_concat(calledFuns, inlinedFuns), key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3):-
  Vulnerability(vulnerability_type, confidence, visibility, tacStmt, key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3),
  Statement_Function(tacStmt, function),
  FunctionReachableFromPublic_Metadata(function, key_selector, _, listPart1, calledFuns),
  Statement_OriginalStatement(tacStmt, key_statement),
  Statement_OriginalStatementList(tacStmt, originalList),
  Statement_InlineInfo(tacStmt, inlinedFuns).

VulnerabilityProcessed(vulnerability_type, confidence, visibility, NULL, nil, nil, key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3):-
  Vulnerability(vulnerability_type, confidence, visibility, tacStmt, key_selector, debug_template, debug_arg0, debug_arg1, debug_arg2, debug_arg3),
  !Statement_OriginalStatement(tacStmt, _).

.output ProtoVulnerability(IO="file", filename="proto_vulnerability.csv", delimiter="\t")
.output VulnerabilityProcessed(IO="file", filename="vulnerability.csv", delimiter="\t")
.output VulnerabilityProcessed(IO=jsonfile, filename="vulnerability.json", format=object)
.output Vulnerability(IO="file", filename="vulnerability_debug.csv", delimiter="\t")

#define PREPARE_JSON1(arg1) cat("{ ", cat(arg1, " }"))
#define PREPARE_JSON2(arg1, arg2) cat("{ ", cat(cat(arg1, ", "), cat(arg2, " }")))
#define PREPARE_JSON3(arg1, arg2, arg3) cat("{ ", cat(cat(cat(arg1, ", "), cat(arg2, ", ")), cat(arg3, " }")))
#define PREPARE_JSON4(arg1, arg2, arg3, arg4) cat("{ ", cat(  cat(cat(arg1, ", "), cat(arg2, ", ")), cat(cat(arg3, ", "), cat(arg4, " }"))))
#define QUOTE substr("\"", 0, 1)   // I could find no other way to get an escaped quote!
#define STRINGIZE(arg) cat(QUOTE, cat(arg, QUOTE))
#define JSON_ELEMENT(name, value) cat(cat(STRINGIZE(name), " : "), value)
#define JSON_LEAF(name, value) cat(cat(STRINGIZE(name), " : "), STRINGIZE(value))
#define SIGNATURE(pubSig) JSON_LEAF("callerSig", pubSig)
#define CALLEE(pubSig, pubSigHash) JSON_ELEMENT("callee", PREPARE_JSON2(JSON_LEAF("sig", pubSig), JSON_LEAF("sigHash", pubSigHash)))
#define CALL_ARG(pubSig, pubSigHash, arg) PREPARE_JSON2(CALLEE(pubSig,pubSigHash), JSON_LEAF("argPos", to_string(arg)))

