// The parts of the schema of the decompiler output that need to be
// imported in order to produce the full three-address code
// intermediate representation. All the information is there, but this
// code, together with tac_instructions.dl, creates a different
// intermediate representation (often reusing instruction names).

.symbol_type Variable
.symbol_type Statement
.symbol_type Block
.symbol_type Function
.symbol_type Opcode

#define op TAC_Op
#define use(var, stmt, n) TAC_Use(stmt, var, n-1)
#define def(var, stmt) TAC_Def(stmt, var)

#include "tac_instructions.dl"

// Final decompiler outputs
.decl TAC_Op(stmt:Statement, op:Opcode)
.input TAC_Op(IO="file", filename="TAC_Op.csv", delimiter="\t")
.decl TAC_Stmt(stmt:Statement)
.input TAC_Stmt(IO="file", filename="TAC_Stmt.csv", delimiter="\t")
.decl TAC_Use(stmt: Statement, var: Variable, i: number)
.input TAC_Use(IO="file", filename="TAC_Use.csv", delimiter="\t")
.decl TAC_Def(stmt: Statement, var: Variable)
.input TAC_Def(IO="file", filename="TAC_Def.csv", delimiter="\t")
.decl TAC_Var(var: Variable)
.input TAC_Var(IO="file", filename="TAC_Var.csv", delimiter="\t")
.decl TAC_Block(block: Block, stmt: Statement)
.input TAC_Block(IO="file", filename="TAC_Block.csv", delimiter="\t")
.decl TAC_Variable_Value(var: Variable, Value: symbol)
.input TAC_Variable_Value(IO="file", filename="TAC_VariableValue.csv", delimiter="\t")
.decl LocalBlockEdge(block: Block, nextBlock: Block)
.input LocalBlockEdge(IO="file", filename="LocalBlockEdge_Out.csv", delimiter="\t")
.decl FunctionCall(block: Block, function: Function)
.input FunctionCall(IO="file", filename="FunctionCall_Out.csv", delimiter="\t")


.decl ActualArgs(s: Statement, fn: Function, a: Variable, pos: Number)                              
.decl FormalArgs(fn: Function, a: Variable, pos: Number)
.input FormalArgs(IO="file", filename="FunctionArgument_Out.csv", delimiter="\t")
