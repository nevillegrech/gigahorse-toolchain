

.comp SelectiveContextV2 <StaticOnlyGlobalAnalysis>: PublicComponentContextSensitivity <StaticOnlyGlobalAnalysis> {

  // Trivial control flow case for when there is no function call
  // OR max context depth is zero
  // Split into two rules to add plan.
  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    !local.PublicFunctionJump(caller, _, _),
    !local.ImportantExitPoint(_, caller, _),
    !local.EntryPoint(caller).

  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    !local.PublicFunctionJump(caller, _, _),
    DecomposeContext(ctx, pub, _),
    MaxContextDepth(pub, 0).
    .plan 1:(2,3,1)

  // Complex control flow case
  //// Default variant
  MergeContext(ctx, caller, [pub, newPrivateContext]):-
    ReachableContext(ctx, caller),
    local.EntryPoint(caller),
    DecomposeContext(ctx, pub, pri),
    TruncateContextIfNeeded(pub, pri, cutDownPri),
    !local.PublicFunctionJump(caller, _, _),
    newPrivateContext = [caller, cutDownPri].
    .plan 1:(3,1,2,4), 2:(4,3,1,2)

  MergeContext(ctx, caller, [pub, newPrivateContext]):-
    ReachableContext(ctx, caller),
    local.ImportantExitPoint(entry, caller, callerRep),
    DecomposeContext(ctx, pub, pri),
    DecomposePrivateContext(pri, entry, _), // peek
    TruncateContextIfNeeded(pub, pri, cutDownPri),
    !local.PublicFunctionJump(caller, _, _),
    newPrivateContext = [callerRep, cutDownPri].
    .plan 1:(3,1,2,4,5), 2:(4,3,1,2,5), 3:(5,4,3,1,2)

  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    local.ImportantExitPoint(_, caller, _),
    DecomposeContext(ctx, _, pri),
    DecomposePrivateContext(pri, entry, _),
    !local.ImportantExitPoint(entry, caller, _).
    .plan 1:(3,1,2,4), 2:(4,3,1,2)
}