.comp TransactionalWithShrinkingContext <LocalAnalysis> : PublicComponentContextSensitivity <LocalAnalysis> {
  // inverse-escape analysis
  .decl BlockUsesLocal(block: Block, var: VariableOrStackIndex)
  BlockUsesLocal(block, var) :-
    local.Statement_Block(stmt, block),
    local.Statement_Uses_Local(stmt, var, _).

  .decl StaticBlockJumpTarget(caller: Block, target: Value)
  StaticBlockJumpTarget(caller, target) :-
    local.ImmediateBlockJumpTarget(caller, targetVar),
    local.Variable_Value(targetVar, target),
    local.JUMPDEST(as(target, symbol)).

  .decl StaticBlockJumpTargetNonUnique(caller: Block, target: Value)
  StaticBlockJumpTargetNonUnique(caller, target) :-
    StaticBlockJumpTarget(caller, target),
    StaticBlockJumpTarget(caller2, target),
    caller != caller2.

  // pushes a label for later use. A return addr?
  .decl BlockPushesLabel(block: Block, val: Value)
  BlockPushesLabel(block, val) :-
    local.JUMPDEST(as(val, symbol)),
    local.Variable_Value(var, val),
    local.Statement_Defines(stmt, var),
    local.Statement_Block(stmt, block),
    !BlockUsesLocal(block, var).

  .decl PrivateFunctionCall(caller: Block, callee: Block, continuation: Block)
  PrivateFunctionCall(caller, as(calleeValue, Block), as(contValue, Block)) :-
    StaticBlockJumpTarget(caller, calleeValue),  // looks like a call
    BlockPushesLabel(caller, contValue).       // looks like pushing a return

  .decl MultiplePrivateFunctionCall(caller: Block)
  MultiplePrivateFunctionCall(caller) :-
    PrivateFunctionCall(caller, callee, cont1),
    PrivateFunctionCall(caller, callee, cont2),
    cont1 != cont2.
   .plan 1:(2,1)

  .decl PrivateFunctionReturn(returnBlock: Block)
  PrivateFunctionReturn(returnBlock) :-
    local.Statement_Block(stmt, returnBlock),
    local.JUMP(stmt),
    !local.ImmediateBlockJumpTarget(returnBlock, _).

  .decl PrivateFunctionCallOrReturn(block: Block)
  PrivateFunctionCallOrReturn(block) :-
    PrivateFunctionCall(block, _, _);
    PrivateFunctionReturn(block).

  // Trivial control flow case for when there is no function call
  // OR max context depth is zero
  // Split into two rules to add plan.
  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(caller, _),
    #endif
    !PrivateFunctionCallOrReturn(caller).

  MergeContext(ctx, caller, ctx):-
    ReachableContext(ctx, caller),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(caller, _),
    #endif
    DecomposeContext(ctx, pub, _),
    MaxContextDepth(pub, 0).
    .plan 1:(2,3,1)


  ///// VARIANT 1

  //// Always drop head (not adding anything) upon a return

  // // Complex control flow case
  // MergeContext(ctx, caller, [pub, newPrivateContext]):-
  //   ReachableContext(ctx, caller),
  //   PrivateFunctionCall(caller, _, _),
  //   DecomposeContext(ctx, pub, pri),
  //   TruncateContextIfNeeded(pub, pri, cutDownPri),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(caller, _),
  //   #endif
  //   newPrivateContext = [caller, cutDownPri].
  //   .plan 1:(3,1,2,4), 2:(4,3,1,2)

  // .decl DecomposeAndCutContext(ctx: Context, publicFun: symbol, private: PrivateContext)
  // DecomposeAndCutContext(ctx, pubFun, privCtx) :-
  //   DecomposeContext(ctx, pubFun, privCtx),
  //   InitialPrivateContext(privCtx). // only nil

  // DecomposeAndCutContext(ctx, pubFun, rest) :-
  //   DecomposeContext(ctx, pubFun, privCtx),
  //   DecomposePrivateContext(privCtx, _, rest).
  //  .plan 1:(2,1)

  // MergeContext(ctx, block, [pub, cutDownPri]):-
  //   ReachableContext(ctx, block),
  //   PrivateFunctionReturn(block),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(block, _),
  //   #endif
  //   DecomposeAndCutContext(ctx, pub, cutDownPri).
  //   .plan 1:(3,1,2)





  // Some helpers
  .decl DecomposeAndTruncateIfNeeded(ctx: Context, publicFun: symbol, cutDownPri: PrivateContext)
  DecomposeAndTruncateIfNeeded(ctx, pub, cutDownAtEndPri) :-
    DecomposeContext(ctx, pub, pri),
    TruncateContextIfNeeded(pub, pri, cutDownAtEndPri).
   .plan 1:(2,1)

  .decl DecomposePublicAndPrivateContext(ctx: Context, publicFun: symbol, priCtx: PrivateContext, head: Block, private: PrivateContext)
  DecomposePublicAndPrivateContext(ctx, pubFun, privCtx, "dummyBlock", privCtx) :-
    DecomposeContext(ctx, pubFun, privCtx),
    InitialPrivateContext(privCtx). // only nil

  DecomposePublicAndPrivateContext(ctx, pubFun, privCtx, head, rest) :-
    DecomposeContext(ctx, pubFun, privCtx),
    DecomposePrivateContext(privCtx, head, rest).
   .plan 1:(2,1)


  // ///// VARIANT 2
  // /// If call matches return, drop it when encountering return

  // // Complex control flow case
  // MergeContext(ctx, caller, [pub, newPrivateContext]):-
  //   ReachableContext(ctx, caller),
  //   PrivateFunctionCall(caller, _, _),
  //   DecomposeAndTruncateIfNeeded(ctx, pub, cutDownPri),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(caller, _),
  //   #endif
  //   newPrivateContext = [caller, cutDownPri].
  //   .plan 1:(3,1,2)

  // MergeContextResponse(ctx, block, nextBlock, [pub, cutDownPri]):-
  //   MergeContextRequest(ctx, block, nextBlock),
  //   PrivateFunctionReturn(block),
  //   DecomposePublicAndPrivateContext(ctx, pub, _, head, cutDownPri),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(block, _),
  //   #endif
  //   PrivateFunctionCall(head, _, nextBlock).
  //   .plan 1:(3,1,2,4)

  // MergeContextResponse(ctx, block, nextBlock, [pub, newPrivateContext]):-
  //   MergeContextRequest(ctx, block, nextBlock),
  //   PrivateFunctionReturn(block),
  //   DecomposePublicAndPrivateContext(ctx, pub, _, head, _),
  //   DecomposeAndTruncateIfNeeded(ctx, pub, cutDownPri),
  //   !PrivateFunctionCall(head, _, nextBlock),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(block, _),
  //   #endif
  //   newPrivateContext = [block, cutDownPri].
  //   .plan 1:(3,1,2,4), 2:(4,3,1,2)





  ///// VARIANT 3

  // // Complex control flow cases
  // /// If a call -> append self (truncating end if needed)
  // MergeContext(ctx, caller, [pub, newPrivateContext]):-
  //   ReachableContext(ctx, caller),
  //   PrivateFunctionCall(caller, _, _),
  //   DecomposeAndTruncateIfNeeded(ctx, pub, cutDownAtEndPri),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(caller, _),
  //   #endif
  //   newPrivateContext = [caller, cutDownAtEndPri].
  //   .plan 1:(3,1,2)


  // // if return, matching call exists -> drop stack head elements until matching call found, drop that too, append self

  // .decl CutToCaller1(priCtx: PrivateContext, continuation: Block, newPriCtx: PrivateContext)
  // CutToCaller1(priCtx, cont, newPriCtx) :-
  //   DecomposePrivateContext(priCtx, head, newPriCtx),
  //   PrivateFunctionCall(head, _, cont).

  // // Limit to 2 steps. Otherwise perhaps imprecise.
  // .decl CutToCaller(priCtx: PrivateContext, continuation: Block, newPriCtx: PrivateContext)
  // CutToCaller(priCtx, cont, newPriCtx) :-
  //   CutToCaller1(nextPriCtx, cont, newPriCtx),
  //   DecomposePrivateContext(priCtx, head, nextPriCtx),
  //   !PrivateFunctionCall(head, _, cont).
  //   .plan 1:(2,1)
    
  // MergeContextResponse(ctx, block, cont, [pub, newPrivateContext]):-
  //   MergeContextRequest(ctx, block, cont),
  //   PrivateFunctionReturn(block),
  //   DecomposeContext(ctx, pub, priCtx),
  //   CutToCaller(priCtx, cont, cutPri),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(block, _),
  //   #endif
  //   newPrivateContext = [block, cutPri].
  //   .plan 1:(3,1,2,4), 2:(4,3,1,2)

  // // if return and matching call doesn't exist -> append self (truncating end if needed)
  // MergeContextResponse(ctx, block, cont, [pub, newPrivateContext]):-
  //   MergeContextRequest(ctx, block, cont),
  //   PrivateFunctionReturn(block),
  //   DecomposeContext(ctx, pub, priCtx),
  //   DecomposeAndTruncateIfNeeded(ctx, pub, cutDownAtEndPri),
  //   NoCutToCaller(priCtx, cont),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(block, _),
  //   #endif
  //   newPrivateContext = [block, cutDownAtEndPri].
  //   .plan 1:(3,1,2,4,5), 2:(4,3,1,2,5), 3:(5,3,1,2,4)




  ///// VARIANT 4

  // Complex control flow cases
  /// If a call -> append self (truncating end if needed)
  MergeContext(ctx, caller, [pub, newPrivateContext]):-
    ReachableContext(ctx, caller),
    PrivateFunctionCall(caller, _, _),
    DecomposeAndTruncateIfNeeded(ctx, pub, cutDownAtEndPri),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(caller, _),
    #endif
    newPrivateContext = [caller, cutDownAtEndPri].
    .plan 1:(3,1,2)

  // if return, matching call exists, call is not a sequence -> drop stack head elements until matching call found, drop that too
  .decl CutToCaller(priCtx: PrivateContext, continuation: Block, newPriCtx: PrivateContext)
  CutToCaller(priCtx, cont, newPriCtx) :-
    DecomposePrivateContext(priCtx, head, newPriCtx),
    PrivateFunctionCall(head, _, cont),
    !MultiplePrivateFunctionCall(head).

  CutToCaller(priCtx, cont, newPriCtx) :-
    CutToCaller(nextPriCtx, cont, newPriCtx),
    DecomposePrivateContext(priCtx, head, nextPriCtx),
    !PrivateFunctionCall(head, _, cont).
    .plan 1:(2,1)

  .decl PossibleContinuationFromReturn(continuation: Block)
  PossibleContinuationFromReturn(continuation) :-
    MergeContextRequest(_, retBlock, continuation),
    PrivateFunctionReturn(retBlock).
    
  .decl NoCutToCaller(priCtx: PrivateContext, continuation: Block)
  NoCutToCaller(initPriCtx, cont) :-
    PossibleContinuationFromReturn(cont),
    InitialPrivateContext(initPriCtx).

  NoCutToCaller(priCtx, cont) :-
    NoCutToCaller(nextPriCtx, cont),
    DecomposePrivateContext(priCtx, head, nextPriCtx),
    !PrivateFunctionCall(head, _, cont).
    .plan 1:(2,1)

  NoCutToCaller(priCtx, cont) :-
    NoCutToCaller(nextPriCtx, cont),
    DecomposePrivateContext(priCtx, head, nextPriCtx),
    MultiplePrivateFunctionCall(head).
    .plan 1:(2,1,3)

  NoCutToCaller(priCtx, cont) :-
    CutToCaller(nextPriCtx, cont, _),
    DecomposePrivateContext(priCtx, head, nextPriCtx),
    PrivateFunctionCall(head, _, cont),
    MultiplePrivateFunctionCall(head).
    .plan 1:(2,1,3,4)


  MergeContextResponse(ctx, block, cont, [pub, cutPri]):-
    MergeContextRequest(ctx, block, cont),
    PrivateFunctionReturn(block),
    DecomposeContext(ctx, pub, priCtx),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(block, _),
    #endif
    CutToCaller(priCtx, cont, cutPri).
    .plan 1:(3,1,2,4), 2:(4,3,1,2)

  // // if return and matching call doesn't exist -> leave context unchanged
  // MergeContextResponse(ctx, block, cont, ctx):-
  //   MergeContextRequest(ctx, block, cont),
  //   PrivateFunctionReturn(block),
  //   DecomposeContext(ctx, _, priCtx),
  //   #ifndef NO_PUBLIC_CONTEXT
  //   !local.PublicFunction(block, _),
  //   #endif
  //   NoCutToCaller(priCtx, cont).
  //   .plan 1:(3,1,2,4), 2:(4,3,1,2)

  // // if return and matching call doesn't exist -> push return
  MergeContextResponse(ctx, block, cont, [pub, newPrivateContext]):-
    MergeContextRequest(ctx, block, cont),
    PrivateFunctionReturn(block),
    DecomposeContext(ctx, pub, priCtx),
    DecomposeAndTruncateIfNeeded(ctx, pub, cutDownAtEndPri),
    NoCutToCaller(priCtx, cont),
    #ifndef NO_PUBLIC_CONTEXT
    !local.PublicFunction(block, _),
    #endif
    newPrivateContext = [block, cutDownAtEndPri].
    .plan 1:(3,1,2,4,5), 2:(4,3,1,2,5), 3:(5,3,1,2,4)


}