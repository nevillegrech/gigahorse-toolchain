// The core of the decompiler logic. Most complex reasoning for value
// flow and detecting CFG edges (much like the Vandal decompiler) is here.

#define MAX_STACK_HEIGHT 50
#define LIMITSIZE_BLOCK_OUTPUT_CONTENTS 5000000
#define CheckIsVariable(v) ((v) < 0)
#define CheckIsStackIndex(v) ((v) >= 0, (v) < MAX_STACK_HEIGHT)
#define CheckIsPopDelta(v) ((v) >= 0, (v) < MAX_STACK_HEIGHT)
#define CheckIsStackDelta(n) ((n) < MAX_STACK_HEIGHT, (n) > -MAX_STACK_HEIGHT)
#define FUNCTION_SELECTOR "0x0"

#include "../clientlib/util.dl"
#include "local.dl"

#include "decompiler_input_opcodes.dl"


.type Block <: symbol
.type Value <: symbol
.type Variable <: number
.type StackIndex <: number
.type VariableOrStackIndex = Variable | StackIndex
.type Opcode <: symbol
.type Statement <: symbol
.type FunctionSignature <: symbol

.init global = OptimizedGlobalAnalysis<CONTEXT_SENSITIVITY>

COPY_CODE(global, postTrans)

// Masks with all 1s
.decl Mask_Length(mask: Value, bytes: number)
.decl PreMask_Length(mask: symbol, bytes: number)

Mask_Length(cat("0x", mask), bytes) :-
   PreMask_Length(mask, bytes).

PreMask_Length("1", 1).
PreMask_Length("3", 1).
PreMask_Length("7", 1).
PreMask_Length("f", 1).
PreMask_Length("1f", 1).
PreMask_Length("3f", 1).
PreMask_Length("7f", 1).
PreMask_Length("ff", 1).

PreMask_Length(cat("ff", mask), bytes+1) :-
  PreMask_Length(mask, bytes),
  bytes < 32.


.comp GlobalAnalysis <AbstractContextSensitivity> : PreTransLocalAnalysis {
  /*
  ***********
  * Key dataflow definitions
  ***********
  */

  .init sens = AbstractContextSensitivity <StaticOnlyGlobalAnalysis>

  sens.local.PushValue(push, val):- PushValue(push, val).
  sens.local.Statement_Opcode(stmt, op):- Statement_Opcode(stmt, op).
  sens.local.Statement_Next(stmt, stmtNext):- Statement_Next(stmt, stmtNext).

  // `block` is reachable under `context`
  .decl ReachableContext(context: sens.Context, block: Block)

  // Stack contents at end of a `block`, given its calling `context`.
  .decl BlockOutputContents(context: sens.Context, block: Block, index: StackIndex, var: Variable)
  #ifdef ENABLE_LIMITSIZE
  .limitsize BlockOutputContents(n=LIMITSIZE_BLOCK_OUTPUT_CONTENTS)
  #endif

  DEBUG_OUTPUT(BlockOutputContents)
  DEBUG_OUTPUT(BlockInputContents)

  /**
    Stack contents at start of a `block`, given its calling `context`.
    Added overridable flag to override it in the optimized variant of the component
  */
  .decl BlockInputContents(context: sens.Context, block: Block, index: StackIndex, var: Variable) overridable

  // `var` holds the (target block) address a `block` jumps to, under `context`.
  .decl BlockJumpTarget(context: sens.Context, block: Block, var: Variable)

  /**
    Under `ctx`, the `block` will jump to the value of `var`, which
    is equal to the label of the `target` block.
  */
  .decl BlockJumpValidTarget(ctx: sens.Context, block: Block, var: Variable, target: Block)

  /**
    When `block` is analyzed under `callerCtx`, there will be a CFG edge
    from `block` to `callee`, causing it to be reachable under `calleeCtx`
  */
  .decl BlockEdge(callerCtx: sens.Context, caller: Block, calleeCtx: sens.Context, callee: Block)
  


  /*
  ***********
  * Define block's behavior based on constituents
  ***********
  */

  BlockInputContents(calleeCtx, callee, index, variable) :-
    BlockOutputContents(callerCtx, caller, index, variable),
    BlockEdge(callerCtx, caller, calleeCtx, callee).
    .plan 1:(2,1)
    
  // Copy the stack variables untouched by the callee basic block
  BlockOutputContents(calleeCtx, callee, index+delta, variable) :-
    BlockInputContents(calleeCtx, callee, index, variable),
    BlockPopDelta(callee, calleePopLen),
    BlockStackDelta(callee, delta),
    index >= calleePopLen,
    index+delta <= MAX_STACK_HEIGHT.

  // Handle the proper variables pushed by this basic block
  BlockOutputContents(ctx, block, index, as(var, Variable)) :-
    ReachableContext(ctx, block),
    BasicBlock_Tail(block, stmt),
    LocalStackContents(stmt, index, var),
    CheckIsVariable(var).


  // Handle the stackIndexes pushed by this basic block
  BlockOutputContents(ctx, block, index, as(realVariable, Variable)) :-
    BlockInputContents(ctx, block, stackIndex, realVariable),
    CheckIsStackIndex(stackIndex),
    BasicBlock_Tail(block, stmt),
    LocalStackContents(stmt, index, stackIndex).



  BlockJumpTarget(ctx, block, var) :-
    ReachableContext(ctx, block),
    ImmediateBlockJumpTarget(block, var).

  BlockJumpTarget(ctx, block, realVariable) :-
    BlockInputContents(ctx, block, stackIndex, realVariable),
    CheckIsStackIndex(stackIndex),
    BasicBlock_Tail(block, stmt),
    IsJump(stmt),
    BeforeLocalStackContents(stmt, 0, stackIndex).

  BlockJumpValidTarget(ctx, block, targetVar, as(targetValue, Block)) :-
    BlockJumpTarget(ctx, block, targetVar),
    Variable_Value(targetVar, targetValue),
    JUMPDEST(as(targetValue, symbol)).


  /*
  ***********
  * CFG edges and reachable contexts
  ***********
  */

  ReachableContext(calleeCtx, callee) :-
    BlockEdge(_, _, calleeCtx, callee).
    
  ReachableContext(initCtx, FUNCTION_SELECTOR) :-
    sens.InitialContext(initCtx).

  .decl FallthroughEdge(caller: Block, fallthroughBlock: Block)

  FallthroughEdge(caller, as(fallthrough, Block)),
  BlockEdge(callerCtx, caller, calleeCtx, as(fallthrough, Block)) :-
    sens.MergeContext(callerCtx, caller, calleeCtx),  // implies reachable
    Statement_Block(stmt, caller),
    FallthroughStmt(stmt, fallthrough),
    IsBasicBlockHead(fallthrough).

  BlockEdge(callerCtx, caller, calleeCtx, callee) :-
    BlockJumpValidTarget(callerCtx, caller, _, callee),
    sens.MergeContext(callerCtx, caller, calleeCtx).
    .plan 1:(2,1)


  .decl Statement_Uses(stmt: Statement, var: Variable, n: StackIndex)

  // Case: variable originates locally
  Statement_Uses(stmt, as(var, Variable), n) :-
    Statement_Uses_Local(stmt, var, n),
    CheckIsVariable(var).

  // Case: variable originates elsewhere
  Statement_Uses(stmt, var, n) :-
    Statement_Uses_Local(stmt, stackIndex, n),
    CheckIsStackIndex(stackIndex),
    Statement_Block(stmt, block),
    BlockInputContents(_, block, stackIndex, var).

  .decl VariableContainsJumpTarget(var: Variable)
  VariableContainsJumpTarget(var) :-
    Variable_Value(var, value),
    JUMPDEST(as(value, symbol)).

  .decl VariableUsedInOperation(var: Variable)

  VariableUsedInOperation(var):-
    Statement_Uses(stmt, var, _),
    Statement_Opcode(stmt, op),
    op != "JUMP",
    op != "JUMPI".

  VariableUsedInOperation(var):-
    Statement_Uses(stmt, var, 1),
    Statement_Opcode(stmt, "JUMPI").

  .decl VariableAlwaysUsedAsJumpTarget(var: Variable)

  VariableAlwaysUsedAsJumpTarget(var):-
    VariableContainsJumpTarget(var),
    !VariableUsedInOperation(var).
}

/**
  A global analysis component optimized by only modeling the stack locations containing jump targets
*/
.comp OptimizedGlobalAnalysis <AbstractContextSensitivity> : GlobalAnalysis <AbstractContextSensitivity> {

  .override BlockInputContents

  /**
    Cut down `BlockOutputContents`, only containing jump targets.
    Stack contents at end of a `block`, given its calling `context`.
  */
  .decl AuxBlockOutputContentsJumpTarget(context:sens.Context, block:Block, index:StackIndex, var:Variable)
  AuxBlockOutputContentsJumpTarget(context, block, index, var) :-
    BlockOutputContents(context, block, index, var),
    VariableContainsJumpTarget(var).

  BlockInputContents(calleeCtx, callee, index, variable) :-
    AuxBlockOutputContentsJumpTarget(callerCtx, caller, index, variable),
    BlockEdge(callerCtx, caller, calleeCtx, callee).
    .plan 1:(2,1)
}

/**
  Declared just so it can be used as a parameter in another component
*/
.comp DefaultOptimizedGlobalAnalysis : OptimizedGlobalAnalysis <TransactionalContext> {

}


.comp StaticOnlyGlobalAnalysis : PreTransLocalAnalysis {

  .decl EntryPoint(block: Block)
  DEBUG_OUTPUT(EntryPoint)

  .decl ReachableUnderEntry(entry: Block, block: Block)
  DEBUG_OUTPUT(ReachableUnderEntry)

  /**
    Stack contents at end of a `block`, given its `entry` point.
    Backwards analysis starting from nonImmediateJumps
  */
  .decl BlockOutputExitJumpdestIndex(entry: Block, exit: Block, block: Block, index: StackIndex)
  DEBUG_OUTPUT(BlockOutputExitJumpdestIndex)
  
  /**
    Stack contents at start of a `block`, given its `entry` point.
  */
  .decl BlockInputExitJumpdestIndex(entry: Block, exit: Block, block: Block, index: StackIndex)
  DEBUG_OUTPUT(BlockInputExitJumpdestIndex)

  .decl LostIt(entry: Block, exit: Block, block: Block, index: StackIndex)
  DEBUG_OUTPUT(LostIt)

  .decl DirectBlockEdge(from: Block, to: Block)

  .decl NonImmediateExitPoint(entry: Block, exit: Block, jumpDestStackIndex: StackIndex)

  .decl ImmediateExitPoint(entry: Block, exit: Block, next: Block)

  .decl InternallyResolvedJumpdest(entry: Block, exit: Block, pushBlock: Block, target: Block)

  .decl ExternallyProvidedJumpdest(entry: Block, exit: Block, jumpDestStackIndex: StackIndex)

  DEBUG_OUTPUT(ImmediateExitPoint)
  DEBUG_OUTPUT(NonImmediateExitPoint)
  DEBUG_OUTPUT(DirectBlockEdge)
  DEBUG_OUTPUT(BlockStackDelta)
  DEBUG_OUTPUT(BlockPopDelta)
  DEBUG_OUTPUT(LocalStackContents)
  DEBUG_OUTPUT(InternallyResolvedJumpdest)
  DEBUG_OUTPUT(ExternallyProvidedJumpdest)

  .decl MissingProvidedJumpdest(entry: Block, exit: Block)
  DEBUG_OUTPUT(MissingProvidedJumpdest)
  EntryPoint("0x0").

  EntryPoint(as(value, Block)):-
    IsJump(jump),
    LocalStackContents(jump, _, var),
    Variable_Value(var, value),
    JUMPDEST(as(value, Statement)).
  
  // New: Also consider possible function entry points
  EntryPoint(as(target, Block)):-
    IsJump(jump),
    LocalStackContents(jump, _, var),
    Variable_Value(var, value),
    JUMPDEST(as(value, Statement)),
    BasicBlock_Tail(block, jump),
    ImmediateBlockJumpTarget(block, targetVar),
    Variable_Value(targetVar, target),
    JUMPDEST(as(target, Statement)).

  ReachableUnderEntry(entry, entry):-
    EntryPoint(entry).

  ReachableUnderEntry(entry, next):-
    ReachableUnderEntry(entry, block),
    DirectBlockEdge(block, next),
    !EntryPoint(next). // New: cannot reach another entry point


  DirectBlockEdge(from, as(value, Block)):-
    ImmediateBlockJumpTarget(from, var),
    Variable_Value(var, value).

  DirectBlockEdge(from, as(next, Block)):-
    FallthroughStmt(fallthrough, next),
    BasicBlock_Tail(from, fallthrough).
  
  NonImmediateExitPoint(entry, exit, as(stackIndex, StackIndex)):-
    ReachableUnderEntry(entry, exit),
    BasicBlock_Tail(exit, jump),
    IsJump(jump),
    BeforeLocalStackContents(jump, 0, stackIndex),
    CheckIsStackIndex(stackIndex),
    !ImmediateBlockJumpTarget(exit, _).
  
  ImmediateExitPoint(entry, exit, next):-
    ReachableUnderEntry(entry, exit),
    DirectBlockEdge(exit, next),
    EntryPoint(next).

  BlockInputExitJumpdestIndex(entry, exit, exit, index):-
    NonImmediateExitPoint(entry, exit, index).

  BlockOutputExitJumpdestIndex(entry, exit, prev, index):-
    DirectBlockEdge(prev, next),
    ReachableUnderEntry(entry, prev),
    BlockInputExitJumpdestIndex(entry, exit, next, index),
    // !EntryPoint(next),
    next != entry.

  BlockInputExitJumpdestIndex(entry, exit, block, index - delta) :-
    BlockOutputExitJumpdestIndex(entry, exit, block, index),
    BlockStackDelta(block, delta),
    //BlockPopDelta(block, popLen),
    //index >= popLen,
    BasicBlock_Tail(block, stmt),
    !LocalStackContents(stmt, index, _),
    index - delta >= 0. // SL: Do we really need to specify that?

  LostIt(entry, exit, block, index - delta) :-
    BlockOutputExitJumpdestIndex(entry, exit, block, index),
    BlockStackDelta(block, delta),
    // BlockPopDelta(block, popLen),
    // index >= popLen,
    BasicBlock_Tail(block, stmt),
    !LocalStackContents(stmt, index, _),
    index - delta < 0.

  BlockInputExitJumpdestIndex(entry, exit, block, as(stackIndex, StackIndex)):-
    BlockOutputExitJumpdestIndex(entry, exit, block, index),
    BasicBlock_Tail(block, stmt),
    LocalStackContents(stmt, index, stackIndex),
    CheckIsStackIndex(stackIndex).
  
  InternallyResolvedJumpdest(entry, exit, block, as(target, Block)):-
    BlockOutputExitJumpdestIndex(entry, exit, block, index),
    BasicBlock_Tail(block, stmt),
    LocalStackContents(stmt, index, var),
    CheckIsVariable(var),
    Variable_Value(var, target).

  ExternallyProvidedJumpdest(entry, exit, index):-
    BlockInputExitJumpdestIndex(entry, exit, entry, index).

  MissingProvidedJumpdest(entry, exit):-
    EntryPoint(entry),
    entry != "0x0",
    NonImmediateExitPoint(entry, exit, _),
    !InternallyResolvedJumpdest(entry, exit, _, _),
    !ExternallyProvidedJumpdest(entry, exit, _).
  
  .decl MoreThanOneExternallyProvidedJumpdests(entry: Block)
  DEBUG_OUTPUT(MoreThanOneExternallyProvidedJumpdests)

  MoreThanOneExternallyProvidedJumpdests(entry):-
    ExternallyProvidedJumpdest(entry, _, index),
    ExternallyProvidedJumpdest(entry, _, index2),
    index != index2.

  .decl ExternallyProvidedJumpdest_Rep(entry: Block, exit: Block, rep: Block)
  DEBUG_OUTPUT(ExternallyProvidedJumpdest_Rep)

  ExternallyProvidedJumpdest_Rep(entry, exit, rep):-
    ExternallyProvidedJumpdest(entry, exit, index),
    // ExternallyProvidedJumpdest(entry, exit2, index), exit1 != exit2,
    repOrd = min a:{ExternallyProvidedJumpdest(entry, exit3, index), a = ord(exit3)},
    ExternallyProvidedJumpdest(entry, rep, index),
    ord(rep) = repOrd.

  .decl ImmediateExitPointsSameTarget(entry: Block, exit1: Block, exit2: Block, target: Block)
  DEBUG_OUTPUT(ImmediateExitPointsSameTarget)

  ImmediateExitPointsSameTarget(entry, exit1, exit2, target):-
    ImmediateExitPoint(entry, exit1, target),
    ImmediateExitPoint(entry, exit2, target),
    // This generalization had no effect
    // (ImmediateExitPoint(entry, exit2, target); InternallyResolvedJumpdest(entry, exit2, _, target)),
    exit1 != exit2.

  // TODO: Add heuristic that uses MoreThanOneExitBlocksSameIndex_Rep
  .decl ImportantExitPoint(entry: Block, exit: Block, rep: Block)
  DEBUG_OUTPUT(ImportantExitPoint)

  ImportantExitPoint(entry, exit, exit):-
    ImmediateExitPointsSameTarget(entry, exit, _, _).

  ImportantExitPoint(entry, exit, exit):-
    InternallyResolvedJumpdest(entry, exit, _, _).

  // BAD!
  // ImportantExitPoint(entry, exit, exit):-
  //   ImmediateExitPoint(entry, exit, _),
  //   ExternallyProvidedJumpdest(entry, _, _).

  // ImportantExitPoint(entry, pushBlock, pushBlock):-
  //   InternallyResolvedJumpdest(entry, _, pushBlock, _).

  // Don't know how often this will happen but I've seen it
  // Note that its not an exit point. Could it affect us?
  // No effect 
  ImportantExitPoint(entry, pushBlock1, pushBlock1):-
    InternallyResolvedJumpdest(entry, exit1, pushBlock1, target),
    InternallyResolvedJumpdest(entry, exit2, pushBlock2, target),
    exit1 != exit2, pushBlock1 != pushBlock2.

  // Too unscalable, doesn't give much precision
  // ImportantExitPoint(entry, exit, rep):-
  //   // MoreThanOneExternallyProvidedJumpdests(entry),
  //   ExternallyProvidedJumpdest_Rep(entry, exit, rep).

  .decl MoreThanOneExitPoints(entry: Block, exit: Block)
  DEBUG_OUTPUT(MoreThanOneExitPoints)

  MoreThanOneExitPoints(entry, exit1):-
    (ExternallyProvidedJumpdest(entry, exit1, _); InternallyResolvedJumpdest(entry, exit1, _, _); ImmediateExitPoint(entry, exit1, _)),
    (ExternallyProvidedJumpdest(entry, exit2, _); InternallyResolvedJumpdest(entry, exit2, _, _); ImmediateExitPoint(entry, exit2, _)),
    exit1 != exit2.

}

// .decl Analytics_MoreThanOneExternallyProvidedJumpdests(entry: Block)
// .output Analytics_MoreThanOneExternallyProvidedJumpdests

// Analytics_MoreThanOneExternallyProvidedJumpdests(entry):-
//   global.MoreThanOneExternallyProvidedJumpdests(entry).

// .decl Analytics_MissingProvidedJumpdest(entry: Block)
// .output Analytics_MissingProvidedJumpdest

// Analytics_MissingProvidedJumpdest(entry):-
//   global.MissingProvidedJumpdest(entry, _).