#!/usr/bin/env python3

# Standard lib imports
from os.path import abspath, dirname, join
import sys
import fileinput
import argparse

# Prepend ../src to $PATH so the project modules can be imported below
src_path = join(dirname(abspath(__file__)), "../src")
sys.path.insert(0, src_path)

# Local project imports
import exporter
import dataflow
import tac_cfg
import logger

ll, lm, lh = logger.log_low, logger.log_med, logger.log_high

# Version string to display with -v
VERSION = """\
+------------------------------+
| Ethereum Decompiler v0.0.1   |
| (c) The University of Sydney |
+------------------------------+\
"""

# Define a version() function in case we want dynamic version strings later
def version():
  return VERSION

# Configure argparse
parser = argparse.ArgumentParser(
           description="An EVM bytecode disassembly decompiler that generates"
                       " three-address code for program analysis.")

parser.add_argument("-b",
                    "--bytecode",
                    action="store_true",
                    default=False,
                    help="treat input as bytecode rather than disassembly")

parser.add_argument("-s",
                    "--strict",
                    action="store_true",
                    default=False,
                    help="used in conjunction with -b, unrecognised opcodes "
                         "will not be skipped, but will result in an error.")

parser.add_argument("-g",
                    "--graph",
                    nargs="?",
                    const="graph.dot",
                    metavar="FILE",
                    default=None,
                    help="generate a visual representation of basic block "
                         "relationships with the format inferred from the "
                         "given output filename (cfg.dot by default). "
                         "Non-DOT formats like pdf, png, etc. require "
                         "Graphviz to be installed.")

parser.add_argument("-t",
                    "--tsv",
                    nargs="?",
                    const="",
                    metavar="DIR",
                    default=None,
                    help="generate tab-separated .facts files for Souffle "
                         "and write files to the specified directory, which "
                         "will be recursively created if it does not exist "
                         "(current working directory by default).")

parser.add_argument("-v",
                    "--verbose",
                    action="store_true",
                    help="produce more verbose debug output.")

parser.add_argument("-V",
                    "--version",
                    action="store_true",
                    help="show program's version number and exit.")

parser.add_argument("infile",
                    nargs="?",
                    type=argparse.FileType("r"),
                    default=sys.stdin,
                    help="file from which decompiler input should be read "
                         "(stdin by default).")

parser.add_argument("outfile",
                    nargs="?",
                    type=argparse.FileType("w"),
                    default=sys.stdout,
                    help="file to which decompiler output should be written "
                         "(stdout by default).")

# Do the argparsing
args = parser.parse_args()

# Set global LOG_LEVEL to HIGH if --verbose flag given
if args.verbose:
  logger.LOG_LEVEL = logger.Verbosity.HIGH

# Handle --version
if args.version:
  print(version())
  sys.exit(1)

# Always show version for log_level >= LOW
ll(version())

# Build TAC CFG from input file
try:
  lh("Reading from {}", args.infile.name)
  if args.bytecode:
    cfg = tac_cfg.TACGraph.from_bytecode(args.infile, args.strict)
  else:
    cfg = tac_cfg.TACGraph.from_dasm(args.infile)
  ll("TAC CFG generation completed")

# Catch a Control-C and exit with UNIX failure status 1
except KeyboardInterrupt:
  logger.log("\nInterrupted by user")
  sys.exit(1)

ll("Applying stack analysis TAC CFG")
iterations = 3
break_early = False
for _ in range(iterations):
  if break_early:
    break
  dataflow.stack_analysis(cfg)
  cfg.clone_ambiguous_jump_blocks()
dataflow.stack_analysis(cfg, generate_throws=True)

#cfg.remove_unreachable_code()
#cfg.merge_duplicate_blocks(ignore_preds=True)
cfg.merge_duplicate_blocks(ignore_preds=True, ignore_succs=True)

# Generate output using the requested exporter(s)
ll("Writing string output")
print(exporter.CFGStringExporter(cfg).export(), file=args.outfile)

if args.graph is not None:
  ll("Writing DOT output")
  exporter.CFGDotExporter(cfg).export(args.graph)

if args.tsv is not None:
  ll("Writing TSV output")
  exporter.CFGTsvExporter(cfg).export(args.tsv)
