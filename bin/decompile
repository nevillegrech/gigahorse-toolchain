#!/usr/bin/env python3

# Standard lib imports
from os.path import abspath, dirname, join
import sys
import argparse

# Prepend ../src to $PATH so the project modules can be imported below
src_path = join(dirname(abspath(__file__)), "../src")
sys.path.insert(0, src_path)

# Local project imports
import exporter
import dataflow
import tac_cfg
import logger
import settings

ll, lm, lh = logger.log_low, logger.log_med, logger.log_high

# Version string to display with -v
VERSION = """\
+------------------------------+
| Ethereum Decompiler v0.0.2   |
| (c) The University of Sydney |
+------------------------------+\
"""

# Define a version() function in case we want dynamic version strings later
def version():
  return VERSION

# Configure argparse
parser = argparse.ArgumentParser(
           description="An EVM bytecode disassembly decompiler that generates"
                       " three-address code for program analysis.")

parser.add_argument("-a",
                    "--disassembly",
                    action="store_true",
                    default=False,
                    help="decompile dissassembled input. Overrides '-b'.")

parser.add_argument("-b",
                    "--bytecode",
                    action="store_true",
                    default=False,
                    help="disassemble and decompile bytecode input. This is "
                         "the default mode.")

parser.add_argument("-s",
                    "--strict",
                    action="store_true",
                    default=False,
                    help="used in conjunction with -b, unrecognised opcodes "
                         "will not be skipped, but will result in an error.")

parser.add_argument("-g",
                    "--graph",
                    nargs="?",
                    const="graph.dot",
                    metavar="FILE",
                    default=None,
                    help="generate a visual representation of basic block "
                         "relationships with the format inferred from the "
                         "given output filename (cfg.dot by default). "
                         "Non-DOT formats like pdf, png, etc. require "
                         "Graphviz to be installed. Use html to generate"
                         "an interactive web page of the graph.")

parser.add_argument("-t",
                    "--tsv",
                    nargs="?",
                    const="",
                    metavar="DIR",
                    default=None,
                    help="generate tab-separated .facts files for Souffle "
                         "and write files to the specified directory, which "
                         "will be recursively created if it does not exist "
                         "(current working directory by default).")

parser.add_argument("-d",
                    "--dominators",
                    action="store_true",
                    default=False,
                    help="If producing tsv output, also include graph "
                         "dominator relations.")

parser.add_argument("-o",
                    "--opcodes",
                    nargs="*",
                    default=[],
                    metavar="OPCODE",
                    help="If producing tsv output, also include relations "
                         "encoding all occurrences of the specified "
                         "list of opcodes. Opcode X will be stored in "
                         "op_X.facts.")

parser.add_argument("-I",
                    "--max_iter",
                    type=int,
                    nargs="?",
                    default=-1,
                    const=-1,
                    metavar="ITERATIONS",
                    help="perform no more than the specified number of "
                         "analysis iterations. Lower is faster, but "
                         "potentially less precise. A negative value specifies "
                         "no cap on the iteration count. No cap by default.")

parser.add_argument("-T",
                    "--bail_time",
                    type=int,
                    nargs="?",
                    default=-1,
                    const=-1,
                    metavar="SECONDS",
                    help="begin to terminate the analysis if it's looking to "
                         "take more time than the specified number of seconds. "
                         "Bailing out early may mean the analysis is not able "
                         "to reach a fixed-point, so results may be less "
                         "precise. A negative value means no cap on the "
                         "running time. No cap by default.")

parser.add_argument("-v",
                    "--verbose",
                    action="store_true",
                    help="produce more verbose debug output.")

parser.add_argument("-n",
                    "--no_out",
                    action="store_true",
                    help="do not output decompiled graph.")

parser.add_argument("-W",
                    "--widen_limit",
                    type=int,
                    nargs="?",
                    default=20,
                    const=20,
                    metavar="LIMIT",
                    help="Whenever a stack variable may take more than "
                         "this number of possible values, then widen "
                         "that variable's value to the Top lattice value "
                         "(treat its value as unconstrained). "
                         "Negative values mean no limit. Default value is 20.")

parser.add_argument("-C",
                    "--clamp_stack_minimum",
                    type=int,
                    nargs="?",
                    default=0,
                    const=0,
                    metavar="LIMIT",
                    help="If stacks are growing deeper without more of the "
                         "program's control flow graph being inferred for "
                         "sufficiently many iterations, we can freeze the "
                         "maximum size of these stacks in order to save "
                         "on computation. This threshold will provide a "
                         "lower bound to the size that these stacks can be "
                         "clamped to. Providing a negative value will not "
                         "clamp the stacks. Default value is 0.")

parser.add_argument("-J",
                    "--final_mutate_jumps",
                    action="store_true",
                    help="In the final dataflow iteration, delete or "
                         "specialise jumps if jump conditions are known. "
                         "E.g. JUMPI with a true condition becomes a JUMP.")

parser.add_argument("-H",
                    "--final_no_throws",
                    action="store_false",
                    help="Do not convert JUMPs to THROWs if they are "
                         "known to jump to invalid destinations.")

parser.add_argument("-V",
                    "--version",
                    action="store_true",
                    help="show program's version number and exit.")

parser.add_argument("-S",
                    "--set_valued_ops",
                    action="store_true",
                    help="apply arithmetic operations to variables with "
                         "multiple values; by default, they are only applied "
                         "to variables whose value is definite.")

parser.add_argument("infile",
                    nargs="?",
                    type=argparse.FileType("r"),
                    default=sys.stdin,
                    help="file from which decompiler input should be read "
                         "(stdin by default).")

parser.add_argument("outfile",
                    nargs="?",
                    type=argparse.FileType("w"),
                    default=sys.stdout,
                    help="file to which decompiler output should be written "
                         "(stdout by default).")

# Do the argparsing
args = parser.parse_args()

# Set global LOG_LEVEL to HIGH if --verbose flag given
if args.verbose:
  logger.LOG_LEVEL = logger.Verbosity.HIGH

# Handle --version
if args.version:
  print(version())
  sys.exit(1)

# Always show version for log_level >= LOW
ll(version())

# Build TAC CFG from input file
try:
  lh("Reading from {}", args.infile.name)
  if args.disassembly:
    cfg = tac_cfg.TACGraph.from_dasm(args.infile)
  else:
    cfg = tac_cfg.TACGraph.from_bytecode(args.infile, args.strict)
  ll("TAC CFG generation completed")

# Catch a Control-C and exit with UNIX failure status 1
except KeyboardInterrupt:
  logger.log("\nInterrupted by user")
  sys.exit(1)

ll("Applying stack analysis TAC CFG")

# Initialise data flow settings
settings.max_iterations = args.max_iter
settings.bailout_seconds = args.bail_time
settings.widen_variables = (args.widen_limit >= 0)
settings.widen_threshold = args.widen_limit
settings.clamp_large_stacks = (args.clamp_stack_minimum >= 0)
settings.clamp_stack_minimum = args.clamp_stack_minimum
settings.final_mutate_jumps = args.final_mutate_jumps
settings.final_generate_throws = not args.final_no_throws
settings.set_valued_ops = args.set_valued_ops

# Run data flow analysis
dataflow.analyse_graph(cfg)

# Generate output using the requested exporter(s)
if not args.no_out:
  ll("Writing string output")
  print(exporter.CFGStringExporter(cfg).export(), file=args.outfile)

if args.graph is not None:
  ll("Writing DOT output")
  exporter.CFGDotExporter(cfg).export(args.graph)

if args.tsv is not None:
  ll("Writing TSV output")
  exporter.CFGTsvExporter(cfg).export(output_dir=args.tsv,
                                      dominators=args.dominators,
                                      out_opcodes=args.opcodes)
